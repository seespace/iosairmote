// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "Proto.pb.h"
// @@protoc_insertion_point(imports)

@implementation ProtoRoot
static id<PBExtensionField> DeviceEvent_event = nil;
static id<PBExtensionField> TouchEvent_event = nil;
static id<PBExtensionField> MotionEvent_event = nil;
static id<PBExtensionField> KeypressEvent_event = nil;
static id<PBExtensionField> GestureEvent_event = nil;
static id<PBExtensionField> HandMotionEvent_event = nil;
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [ProtoRoot class]) {
    DeviceEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:100
                                      defaultValue:[DeviceEvent defaultInstance]
                               messageOrGroupClass:[DeviceEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    TouchEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:101
                                      defaultValue:[TouchEvent defaultInstance]
                               messageOrGroupClass:[TouchEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    MotionEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:102
                                      defaultValue:[MotionEvent defaultInstance]
                               messageOrGroupClass:[MotionEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    KeypressEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:103
                                      defaultValue:[KeypressEvent defaultInstance]
                               messageOrGroupClass:[KeypressEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    GestureEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:104
                                      defaultValue:[GestureEvent defaultInstance]
                               messageOrGroupClass:[GestureEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    HandMotionEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:105
                                      defaultValue:[HandMotionEvent defaultInstance]
                               messageOrGroupClass:[HandMotionEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    extensionRegistry = registry;
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
  [registry addExtension:DeviceEvent_event];
  [registry addExtension:TouchEvent_event];
  [registry addExtension:MotionEvent_event];
  [registry addExtension:KeypressEvent_event];
  [registry addExtension:GestureEvent_event];
  [registry addExtension:HandMotionEvent_event];
}
@end

BOOL PhaseIsValidValue(Phase value) {
  switch (value) {
    case PhaseBegan:
    case PhaseMoved:
    case PhaseStationary:
    case PhaseEnded:
    case PhaseCancelled:
      return YES;
    default:
      return NO;
  }
}
@interface Event ()
@property EventType type;
@property SInt64 timestamp;
@end

@implementation Event

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasTimestamp {
  return !!hasTimestamp_;
}
- (void) setHasTimestamp:(BOOL) value_ {
  hasTimestamp_ = !!value_;
}
@synthesize timestamp;
- (void) dealloc {
}
- (id) init {
  if ((self = [super init])) {
    self.type = EventTypeDevice;
    self.timestamp = 0L;
  }
  return self;
}
static Event* defaultEventInstance = nil;
+ (void) initialize {
  if (self == [Event class]) {
    defaultEventInstance = [[Event alloc] init];
  }
}
+ (Event*) defaultInstance {
  return defaultEventInstance;
}
- (Event*) defaultInstance {
  return defaultEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasType) {
    return NO;
  }
  if (!self.hasTimestamp) {
    return NO;
  }
  if (!self.extensionsAreInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  if (self.hasTimestamp) {
    [output writeInt64:2 value:self.timestamp];
  }
  [self writeExtensionsToCodedOutputStream:output
                                      from:100
                                        to:536870912];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  if (self.hasTimestamp) {
    size_ += computeInt64Size(2, self.timestamp);
  }
  size_ += [self extensionsSerializedSize];
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Event*) parseFromData:(NSData*) data {
  return (Event*)[[[Event builder] mergeFromData:data] build];
}
+ (Event*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Event*)[[[Event builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Event*) parseFromInputStream:(NSInputStream*) input {
  return (Event*)[[[Event builder] mergeFromInputStream:input] build];
}
+ (Event*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Event*)[[[Event builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Event*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Event*)[[[Event builder] mergeFromCodedInputStream:input] build];
}
+ (Event*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Event*)[[[Event builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (EventBuilder*) builder {
  return [[EventBuilder alloc] init];
}
+ (EventBuilder*) builderWithPrototype:(Event*) prototype {
  return [[Event builder] mergeFrom:prototype];
}
- (EventBuilder*) builder {
  return [Event builder];
}
- (EventBuilder*) toBuilder {
  return [Event builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
    [output appendFormat:@"%@%@: %d\n", indent, @"type", self.type];
  }
  if (self.hasTimestamp) {
    [output appendFormat:@"%@%@: %@\n", indent, @"timestamp", [NSNumber numberWithLongLong:self.timestamp]];
  }
  [self writeExtensionDescriptionToMutableString:(NSMutableString*)output
                                            from:100
                                              to:536870912
                                      withIndent:indent];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Event class]]) {
    return NO;
  }
  Event *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasTimestamp == otherMessage.hasTimestamp &&
      (!self.hasTimestamp || self.timestamp == otherMessage.timestamp) &&
      [self isEqualExtensionsInOther:otherMessage from:100 to:536870912] &&

      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasTimestamp) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.timestamp] hash];
  }
  hashCode = hashCode * 31 + [self hashExtensionsFrom:100 to:536870912];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL EventTypeIsValidValue(EventType value) {
  switch (value) {
    case EventTypeDevice:
    case EventTypeTouch:
    case EventTypeMotion:
    case EventTypeKeypress:
    case EventTypeGesture:
    case EventTypeHandMotion:
    case EventTypeHandGesture:
      return YES;
    default:
      return NO;
  }
}
@interface EventBuilder()
@property (strong) Event* result;
@end

@implementation EventBuilder
@synthesize result;
- (void) dealloc {
  self.result = nil;
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[Event alloc] init];
  }
  return self;
}
- (PBExtendableMessage*) internalGetResult {
  return result;
}
- (EventBuilder*) clear {
  self.result = [[Event alloc] init];
  return self;
}
- (EventBuilder*) clone {
  return [Event builderWithPrototype:result];
}
- (Event*) defaultInstance {
  return [Event defaultInstance];
}
- (Event*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Event*) buildPartial {
  Event* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (EventBuilder*) mergeFrom:(Event*) other {
  if (other == [Event defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasTimestamp) {
    [self setTimestamp:other.timestamp];
  }
  [self mergeExtensionFields:other];
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (EventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (EventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        EventType value = (EventType)[input readEnum];
        if (EventTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 16: {
        [self setTimestamp:[input readInt64]];
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return result.hasType;
}
- (EventType) type {
  return result.type;
}
- (EventBuilder*) setType:(EventType) value {
  result.hasType = YES;
  result.type = value;
  return self;
}
- (EventBuilder*) clearType {
  result.hasType = NO;
  result.type = EventTypeDevice;
  return self;
}
- (BOOL) hasTimestamp {
  return result.hasTimestamp;
}
- (SInt64) timestamp {
  return result.timestamp;
}
- (EventBuilder*) setTimestamp:(SInt64) value {
  result.hasTimestamp = YES;
  result.timestamp = value;
  return self;
}
- (EventBuilder*) clearTimestamp {
  result.hasTimestamp = NO;
  result.timestamp = 0L;
  return self;
}
@end

@interface Device ()
@property (strong) NSString* name;
@property DeviceVendor vendor;
@property SInt32 version;
@property (strong) NSString* productId;
@property BOOL hasKeyboard;
@end

@implementation Device

- (BOOL) hasName {
  return !!hasName_;
}
- (void) setHasName:(BOOL) value_ {
  hasName_ = !!value_;
}
@synthesize name;
- (BOOL) hasVendor {
  return !!hasVendor_;
}
- (void) setHasVendor:(BOOL) value_ {
  hasVendor_ = !!value_;
}
@synthesize vendor;
- (BOOL) hasVersion {
  return !!hasVersion_;
}
- (void) setHasVersion:(BOOL) value_ {
  hasVersion_ = !!value_;
}
@synthesize version;
- (BOOL) hasProductId {
  return !!hasProductId_;
}
- (void) setHasProductId:(BOOL) value_ {
  hasProductId_ = !!value_;
}
@synthesize productId;
- (BOOL) hasHasKeyboard {
  return !!hasHasKeyboard_;
}
- (void) setHasHasKeyboard:(BOOL) value_ {
  hasHasKeyboard_ = !!value_;
}
- (BOOL) hasKeyboard {
  return !!hasKeyboard_;
}
- (void) setHasKeyboard:(BOOL) value_ {
  hasKeyboard_ = !!value_;
}
- (void) dealloc {
  self.name = nil;
  self.productId = nil;
}
- (id) init {
  if ((self = [super init])) {
    self.name = @"";
    self.vendor = DeviceVendorIos;
    self.version = 0;
    self.productId = @"";
    self.hasKeyboard = NO;
  }
  return self;
}
static Device* defaultDeviceInstance = nil;
+ (void) initialize {
  if (self == [Device class]) {
    defaultDeviceInstance = [[Device alloc] init];
  }
}
+ (Device*) defaultInstance {
  return defaultDeviceInstance;
}
- (Device*) defaultInstance {
  return defaultDeviceInstance;
}
- (BOOL) isInitialized {
  if (!self.hasName) {
    return NO;
  }
  if (!self.hasVendor) {
    return NO;
  }
  if (!self.hasProductId) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasName) {
    [output writeString:1 value:self.name];
  }
  if (self.hasVendor) {
    [output writeEnum:2 value:self.vendor];
  }
  if (self.hasVersion) {
    [output writeInt32:3 value:self.version];
  }
  if (self.hasProductId) {
    [output writeString:4 value:self.productId];
  }
  if (self.hasHasKeyboard) {
    [output writeBool:5 value:self.hasKeyboard];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasName) {
    size_ += computeStringSize(1, self.name);
  }
  if (self.hasVendor) {
    size_ += computeEnumSize(2, self.vendor);
  }
  if (self.hasVersion) {
    size_ += computeInt32Size(3, self.version);
  }
  if (self.hasProductId) {
    size_ += computeStringSize(4, self.productId);
  }
  if (self.hasHasKeyboard) {
    size_ += computeBoolSize(5, self.hasKeyboard);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Device*) parseFromData:(NSData*) data {
  return (Device*)[[[Device builder] mergeFromData:data] build];
}
+ (Device*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Device*)[[[Device builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Device*) parseFromInputStream:(NSInputStream*) input {
  return (Device*)[[[Device builder] mergeFromInputStream:input] build];
}
+ (Device*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Device*)[[[Device builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Device*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Device*)[[[Device builder] mergeFromCodedInputStream:input] build];
}
+ (Device*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Device*)[[[Device builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceBuilder*) builder {
  return [[DeviceBuilder alloc] init];
}
+ (DeviceBuilder*) builderWithPrototype:(Device*) prototype {
  return [[Device builder] mergeFrom:prototype];
}
- (DeviceBuilder*) builder {
  return [Device builder];
}
- (DeviceBuilder*) toBuilder {
  return [Device builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasName) {
    [output appendFormat:@"%@%@: %@\n", indent, @"name", self.name];
  }
  if (self.hasVendor) {
    [output appendFormat:@"%@%@: %d\n", indent, @"vendor", self.vendor];
  }
  if (self.hasVersion) {
    [output appendFormat:@"%@%@: %@\n", indent, @"version", [NSNumber numberWithInteger:self.version]];
  }
  if (self.hasProductId) {
    [output appendFormat:@"%@%@: %@\n", indent, @"productId", self.productId];
  }
  if (self.hasHasKeyboard) {
    [output appendFormat:@"%@%@: %@\n", indent, @"hasKeyboard", [NSNumber numberWithBool:self.hasKeyboard]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Device class]]) {
    return NO;
  }
  Device *otherMessage = other;
  return
      self.hasName == otherMessage.hasName &&
      (!self.hasName || [self.name isEqual:otherMessage.name]) &&
      self.hasVendor == otherMessage.hasVendor &&
      (!self.hasVendor || self.vendor == otherMessage.vendor) &&
      self.hasVersion == otherMessage.hasVersion &&
      (!self.hasVersion || self.version == otherMessage.version) &&
      self.hasProductId == otherMessage.hasProductId &&
      (!self.hasProductId || [self.productId isEqual:otherMessage.productId]) &&
      self.hasHasKeyboard == otherMessage.hasHasKeyboard &&
      (!self.hasHasKeyboard || self.hasKeyboard == otherMessage.hasKeyboard) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasName) {
    hashCode = hashCode * 31 + [self.name hash];
  }
  if (self.hasVendor) {
    hashCode = hashCode * 31 + self.vendor;
  }
  if (self.hasVersion) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.version] hash];
  }
  if (self.hasProductId) {
    hashCode = hashCode * 31 + [self.productId hash];
  }
  if (self.hasHasKeyboard) {
    hashCode = hashCode * 31 + [[NSNumber numberWithBool:self.hasKeyboard] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL DeviceVendorIsValidValue(DeviceVendor value) {
  switch (value) {
    case DeviceVendorIos:
    case DeviceVendorAndroid:
    case DeviceVendorLeapmotion:
    case DeviceVendorKinect:
    case DeviceVendorOther:
      return YES;
    default:
      return NO;
  }
}
@interface DeviceBuilder()
@property (strong) Device* result;
@end

@implementation DeviceBuilder
@synthesize result;
- (void) dealloc {
  self.result = nil;
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[Device alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (DeviceBuilder*) clear {
  self.result = [[Device alloc] init];
  return self;
}
- (DeviceBuilder*) clone {
  return [Device builderWithPrototype:result];
}
- (Device*) defaultInstance {
  return [Device defaultInstance];
}
- (Device*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Device*) buildPartial {
  Device* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (DeviceBuilder*) mergeFrom:(Device*) other {
  if (other == [Device defaultInstance]) {
    return self;
  }
  if (other.hasName) {
    [self setName:other.name];
  }
  if (other.hasVendor) {
    [self setVendor:other.vendor];
  }
  if (other.hasVersion) {
    [self setVersion:other.version];
  }
  if (other.hasProductId) {
    [self setProductId:other.productId];
  }
  if (other.hasHasKeyboard) {
    [self setHasKeyboard:other.hasKeyboard];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (DeviceBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (DeviceBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setName:[input readString]];
        break;
      }
      case 16: {
        DeviceVendor value = (DeviceVendor)[input readEnum];
        if (DeviceVendorIsValidValue(value)) {
          [self setVendor:value];
        } else {
          [unknownFields mergeVarintField:2 value:value];
        }
        break;
      }
      case 24: {
        [self setVersion:[input readInt32]];
        break;
      }
      case 34: {
        [self setProductId:[input readString]];
        break;
      }
      case 40: {
        [self setHasKeyboard:[input readBool]];
        break;
      }
    }
  }
}
- (BOOL) hasName {
  return result.hasName;
}
- (NSString*) name {
  return result.name;
}
- (DeviceBuilder*) setName:(NSString*) value {
  result.hasName = YES;
  result.name = value;
  return self;
}
- (DeviceBuilder*) clearName {
  result.hasName = NO;
  result.name = @"";
  return self;
}
- (BOOL) hasVendor {
  return result.hasVendor;
}
- (DeviceVendor) vendor {
  return result.vendor;
}
- (DeviceBuilder*) setVendor:(DeviceVendor) value {
  result.hasVendor = YES;
  result.vendor = value;
  return self;
}
- (DeviceBuilder*) clearVendor {
  result.hasVendor = NO;
  result.vendor = DeviceVendorIos;
  return self;
}
- (BOOL) hasVersion {
  return result.hasVersion;
}
- (SInt32) version {
  return result.version;
}
- (DeviceBuilder*) setVersion:(SInt32) value {
  result.hasVersion = YES;
  result.version = value;
  return self;
}
- (DeviceBuilder*) clearVersion {
  result.hasVersion = NO;
  result.version = 0;
  return self;
}
- (BOOL) hasProductId {
  return result.hasProductId;
}
- (NSString*) productId {
  return result.productId;
}
- (DeviceBuilder*) setProductId:(NSString*) value {
  result.hasProductId = YES;
  result.productId = value;
  return self;
}
- (DeviceBuilder*) clearProductId {
  result.hasProductId = NO;
  result.productId = @"";
  return self;
}
- (BOOL) hasHasKeyboard {
  return result.hasHasKeyboard;
}
- (BOOL) hasKeyboard {
  return result.hasKeyboard;
}
- (DeviceBuilder*) setHasKeyboard:(BOOL) value {
  result.hasHasKeyboard = YES;
  result.hasKeyboard = value;
  return self;
}
- (DeviceBuilder*) clearHasKeyboard {
  result.hasHasKeyboard = NO;
  result.hasKeyboard = NO;
  return self;
}
@end

@interface DeviceEvent ()
@property DeviceEventType type;
@property (strong) Device* device;
@end

@implementation DeviceEvent

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasDevice {
  return !!hasDevice_;
}
- (void) setHasDevice:(BOOL) value_ {
  hasDevice_ = !!value_;
}
@synthesize device;
- (void) dealloc {
  self.device = nil;
}
- (id) init {
  if ((self = [super init])) {
    self.type = DeviceEventTypeRegister;
    self.device = [Device defaultInstance];
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return DeviceEvent_event;
}
static DeviceEvent* defaultDeviceEventInstance = nil;
+ (void) initialize {
  if (self == [DeviceEvent class]) {
    defaultDeviceEventInstance = [[DeviceEvent alloc] init];
  }
}
+ (DeviceEvent*) defaultInstance {
  return defaultDeviceEventInstance;
}
- (DeviceEvent*) defaultInstance {
  return defaultDeviceEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasType) {
    return NO;
  }
  if (!self.hasDevice) {
    return NO;
  }
  if (!self.device.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  if (self.hasDevice) {
    [output writeMessage:2 value:self.device];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  if (self.hasDevice) {
    size_ += computeMessageSize(2, self.device);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (DeviceEvent*) parseFromData:(NSData*) data {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromData:data] build];
}
+ (DeviceEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (DeviceEvent*) parseFromInputStream:(NSInputStream*) input {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromInputStream:input] build];
}
+ (DeviceEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromCodedInputStream:input] build];
}
+ (DeviceEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceEventBuilder*) builder {
  return [[DeviceEventBuilder alloc] init];
}
+ (DeviceEventBuilder*) builderWithPrototype:(DeviceEvent*) prototype {
  return [[DeviceEvent builder] mergeFrom:prototype];
}
- (DeviceEventBuilder*) builder {
  return [DeviceEvent builder];
}
- (DeviceEventBuilder*) toBuilder {
  return [DeviceEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
    [output appendFormat:@"%@%@: %d\n", indent, @"type", self.type];
  }
  if (self.hasDevice) {
    [output appendFormat:@"%@%@ {\n", indent, @"device"];
    [self.device writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[DeviceEvent class]]) {
    return NO;
  }
  DeviceEvent *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasDevice == otherMessage.hasDevice &&
      (!self.hasDevice || [self.device isEqual:otherMessage.device]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasDevice) {
    hashCode = hashCode * 31 + [self.device hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL DeviceEventTypeIsValidValue(DeviceEventType value) {
  switch (value) {
    case DeviceEventTypeRegister:
    case DeviceEventTypeUnregister:
      return YES;
    default:
      return NO;
  }
}
@interface DeviceEventBuilder()
@property (strong) DeviceEvent* result;
@end

@implementation DeviceEventBuilder
@synthesize result;
- (void) dealloc {
  self.result = nil;
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[DeviceEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (DeviceEventBuilder*) clear {
  self.result = [[DeviceEvent alloc] init];
  return self;
}
- (DeviceEventBuilder*) clone {
  return [DeviceEvent builderWithPrototype:result];
}
- (DeviceEvent*) defaultInstance {
  return [DeviceEvent defaultInstance];
}
- (DeviceEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (DeviceEvent*) buildPartial {
  DeviceEvent* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (DeviceEventBuilder*) mergeFrom:(DeviceEvent*) other {
  if (other == [DeviceEvent defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasDevice) {
    [self mergeDevice:other.device];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (DeviceEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (DeviceEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        DeviceEventType value = (DeviceEventType)[input readEnum];
        if (DeviceEventTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 18: {
        DeviceBuilder* subBuilder = [Device builder];
        if (self.hasDevice) {
          [subBuilder mergeFrom:self.device];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setDevice:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return result.hasType;
}
- (DeviceEventType) type {
  return result.type;
}
- (DeviceEventBuilder*) setType:(DeviceEventType) value {
  result.hasType = YES;
  result.type = value;
  return self;
}
- (DeviceEventBuilder*) clearType {
  result.hasType = NO;
  result.type = DeviceEventTypeRegister;
  return self;
}
- (BOOL) hasDevice {
  return result.hasDevice;
}
- (Device*) device {
  return result.device;
}
- (DeviceEventBuilder*) setDevice:(Device*) value {
  result.hasDevice = YES;
  result.device = value;
  return self;
}
- (DeviceEventBuilder*) setDeviceBuilder:(DeviceBuilder*) builderForValue {
  return [self setDevice:[builderForValue build]];
}
- (DeviceEventBuilder*) mergeDevice:(Device*) value {
  if (result.hasDevice &&
      result.device != [Device defaultInstance]) {
    result.device =
      [[[Device builderWithPrototype:result.device] mergeFrom:value] buildPartial];
  } else {
    result.device = value;
  }
  result.hasDevice = YES;
  return self;
}
- (DeviceEventBuilder*) clearDevice {
  result.hasDevice = NO;
  result.device = [Device defaultInstance];
  return self;
}
@end

@interface TouchEvent ()
@property Float32 locationX;
@property Float32 locationY;
@property Float32 trackareaWidth;
@property Float32 trackareaHeight;
@property Phase phase;
@end

@implementation TouchEvent

- (BOOL) hasLocationX {
  return !!hasLocationX_;
}
- (void) setHasLocationX:(BOOL) value_ {
  hasLocationX_ = !!value_;
}
@synthesize locationX;
- (BOOL) hasLocationY {
  return !!hasLocationY_;
}
- (void) setHasLocationY:(BOOL) value_ {
  hasLocationY_ = !!value_;
}
@synthesize locationY;
- (BOOL) hasTrackareaWidth {
  return !!hasTrackareaWidth_;
}
- (void) setHasTrackareaWidth:(BOOL) value_ {
  hasTrackareaWidth_ = !!value_;
}
@synthesize trackareaWidth;
- (BOOL) hasTrackareaHeight {
  return !!hasTrackareaHeight_;
}
- (void) setHasTrackareaHeight:(BOOL) value_ {
  hasTrackareaHeight_ = !!value_;
}
@synthesize trackareaHeight;
- (BOOL) hasPhase {
  return !!hasPhase_;
}
- (void) setHasPhase:(BOOL) value_ {
  hasPhase_ = !!value_;
}
@synthesize phase;
- (void) dealloc {
}
- (id) init {
  if ((self = [super init])) {
    self.locationX = 0;
    self.locationY = 0;
    self.trackareaWidth = 0;
    self.trackareaHeight = 0;
    self.phase = PhaseBegan;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return TouchEvent_event;
}
static TouchEvent* defaultTouchEventInstance = nil;
+ (void) initialize {
  if (self == [TouchEvent class]) {
    defaultTouchEventInstance = [[TouchEvent alloc] init];
  }
}
+ (TouchEvent*) defaultInstance {
  return defaultTouchEventInstance;
}
- (TouchEvent*) defaultInstance {
  return defaultTouchEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasLocationX) {
    return NO;
  }
  if (!self.hasLocationY) {
    return NO;
  }
  if (!self.hasTrackareaWidth) {
    return NO;
  }
  if (!self.hasTrackareaHeight) {
    return NO;
  }
  if (!self.hasPhase) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasLocationX) {
    [output writeFloat:1 value:self.locationX];
  }
  if (self.hasLocationY) {
    [output writeFloat:2 value:self.locationY];
  }
  if (self.hasTrackareaWidth) {
    [output writeFloat:3 value:self.trackareaWidth];
  }
  if (self.hasTrackareaHeight) {
    [output writeFloat:4 value:self.trackareaHeight];
  }
  if (self.hasPhase) {
    [output writeEnum:5 value:self.phase];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasLocationX) {
    size_ += computeFloatSize(1, self.locationX);
  }
  if (self.hasLocationY) {
    size_ += computeFloatSize(2, self.locationY);
  }
  if (self.hasTrackareaWidth) {
    size_ += computeFloatSize(3, self.trackareaWidth);
  }
  if (self.hasTrackareaHeight) {
    size_ += computeFloatSize(4, self.trackareaHeight);
  }
  if (self.hasPhase) {
    size_ += computeEnumSize(5, self.phase);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (TouchEvent*) parseFromData:(NSData*) data {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromData:data] build];
}
+ (TouchEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TouchEvent*) parseFromInputStream:(NSInputStream*) input {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromInputStream:input] build];
}
+ (TouchEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TouchEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromCodedInputStream:input] build];
}
+ (TouchEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TouchEventBuilder*) builder {
  return [[TouchEventBuilder alloc] init];
}
+ (TouchEventBuilder*) builderWithPrototype:(TouchEvent*) prototype {
  return [[TouchEvent builder] mergeFrom:prototype];
}
- (TouchEventBuilder*) builder {
  return [TouchEvent builder];
}
- (TouchEventBuilder*) toBuilder {
  return [TouchEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasLocationX) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationX", [NSNumber numberWithFloat:self.locationX]];
  }
  if (self.hasLocationY) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationY", [NSNumber numberWithFloat:self.locationY]];
  }
  if (self.hasTrackareaWidth) {
    [output appendFormat:@"%@%@: %@\n", indent, @"trackareaWidth", [NSNumber numberWithFloat:self.trackareaWidth]];
  }
  if (self.hasTrackareaHeight) {
    [output appendFormat:@"%@%@: %@\n", indent, @"trackareaHeight", [NSNumber numberWithFloat:self.trackareaHeight]];
  }
  if (self.hasPhase) {
    [output appendFormat:@"%@%@: %d\n", indent, @"phase", self.phase];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[TouchEvent class]]) {
    return NO;
  }
  TouchEvent *otherMessage = other;
  return
      self.hasLocationX == otherMessage.hasLocationX &&
      (!self.hasLocationX || self.locationX == otherMessage.locationX) &&
      self.hasLocationY == otherMessage.hasLocationY &&
      (!self.hasLocationY || self.locationY == otherMessage.locationY) &&
      self.hasTrackareaWidth == otherMessage.hasTrackareaWidth &&
      (!self.hasTrackareaWidth || self.trackareaWidth == otherMessage.trackareaWidth) &&
      self.hasTrackareaHeight == otherMessage.hasTrackareaHeight &&
      (!self.hasTrackareaHeight || self.trackareaHeight == otherMessage.trackareaHeight) &&
      self.hasPhase == otherMessage.hasPhase &&
      (!self.hasPhase || self.phase == otherMessage.phase) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasLocationX) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationX] hash];
  }
  if (self.hasLocationY) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationY] hash];
  }
  if (self.hasTrackareaWidth) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.trackareaWidth] hash];
  }
  if (self.hasTrackareaHeight) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.trackareaHeight] hash];
  }
  if (self.hasPhase) {
    hashCode = hashCode * 31 + self.phase;
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface TouchEventBuilder()
@property (strong) TouchEvent* result;
@end

@implementation TouchEventBuilder
@synthesize result;
- (void) dealloc {
  self.result = nil;
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[TouchEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TouchEventBuilder*) clear {
  self.result = [[TouchEvent alloc] init];
  return self;
}
- (TouchEventBuilder*) clone {
  return [TouchEvent builderWithPrototype:result];
}
- (TouchEvent*) defaultInstance {
  return [TouchEvent defaultInstance];
}
- (TouchEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TouchEvent*) buildPartial {
  TouchEvent* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (TouchEventBuilder*) mergeFrom:(TouchEvent*) other {
  if (other == [TouchEvent defaultInstance]) {
    return self;
  }
  if (other.hasLocationX) {
    [self setLocationX:other.locationX];
  }
  if (other.hasLocationY) {
    [self setLocationY:other.locationY];
  }
  if (other.hasTrackareaWidth) {
    [self setTrackareaWidth:other.trackareaWidth];
  }
  if (other.hasTrackareaHeight) {
    [self setTrackareaHeight:other.trackareaHeight];
  }
  if (other.hasPhase) {
    [self setPhase:other.phase];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TouchEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TouchEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 13: {
        [self setLocationX:[input readFloat]];
        break;
      }
      case 21: {
        [self setLocationY:[input readFloat]];
        break;
      }
      case 29: {
        [self setTrackareaWidth:[input readFloat]];
        break;
      }
      case 37: {
        [self setTrackareaHeight:[input readFloat]];
        break;
      }
      case 40: {
        Phase value = (Phase)[input readEnum];
        if (PhaseIsValidValue(value)) {
          [self setPhase:value];
        } else {
          [unknownFields mergeVarintField:5 value:value];
        }
        break;
      }
    }
  }
}
- (BOOL) hasLocationX {
  return result.hasLocationX;
}
- (Float32) locationX {
  return result.locationX;
}
- (TouchEventBuilder*) setLocationX:(Float32) value {
  result.hasLocationX = YES;
  result.locationX = value;
  return self;
}
- (TouchEventBuilder*) clearLocationX {
  result.hasLocationX = NO;
  result.locationX = 0;
  return self;
}
- (BOOL) hasLocationY {
  return result.hasLocationY;
}
- (Float32) locationY {
  return result.locationY;
}
- (TouchEventBuilder*) setLocationY:(Float32) value {
  result.hasLocationY = YES;
  result.locationY = value;
  return self;
}
- (TouchEventBuilder*) clearLocationY {
  result.hasLocationY = NO;
  result.locationY = 0;
  return self;
}
- (BOOL) hasTrackareaWidth {
  return result.hasTrackareaWidth;
}
- (Float32) trackareaWidth {
  return result.trackareaWidth;
}
- (TouchEventBuilder*) setTrackareaWidth:(Float32) value {
  result.hasTrackareaWidth = YES;
  result.trackareaWidth = value;
  return self;
}
- (TouchEventBuilder*) clearTrackareaWidth {
  result.hasTrackareaWidth = NO;
  result.trackareaWidth = 0;
  return self;
}
- (BOOL) hasTrackareaHeight {
  return result.hasTrackareaHeight;
}
- (Float32) trackareaHeight {
  return result.trackareaHeight;
}
- (TouchEventBuilder*) setTrackareaHeight:(Float32) value {
  result.hasTrackareaHeight = YES;
  result.trackareaHeight = value;
  return self;
}
- (TouchEventBuilder*) clearTrackareaHeight {
  result.hasTrackareaHeight = NO;
  result.trackareaHeight = 0;
  return self;
}
- (BOOL) hasPhase {
  return result.hasPhase;
}
- (Phase) phase {
  return result.phase;
}
- (TouchEventBuilder*) setPhase:(Phase) value {
  result.hasPhase = YES;
  result.phase = value;
  return self;
}
- (TouchEventBuilder*) clearPhase {
  result.hasPhase = NO;
  result.phase = PhaseBegan;
  return self;
}
@end

@interface MotionEvent ()
@property MotionEventType type;
@end

@implementation MotionEvent

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (void) dealloc {
}
- (id) init {
  if ((self = [super init])) {
    self.type = MotionEventTypeShake;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return MotionEvent_event;
}
static MotionEvent* defaultMotionEventInstance = nil;
+ (void) initialize {
  if (self == [MotionEvent class]) {
    defaultMotionEventInstance = [[MotionEvent alloc] init];
  }
}
+ (MotionEvent*) defaultInstance {
  return defaultMotionEventInstance;
}
- (MotionEvent*) defaultInstance {
  return defaultMotionEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasType) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (MotionEvent*) parseFromData:(NSData*) data {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromData:data] build];
}
+ (MotionEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (MotionEvent*) parseFromInputStream:(NSInputStream*) input {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromInputStream:input] build];
}
+ (MotionEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MotionEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromCodedInputStream:input] build];
}
+ (MotionEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MotionEventBuilder*) builder {
  return [[MotionEventBuilder alloc] init];
}
+ (MotionEventBuilder*) builderWithPrototype:(MotionEvent*) prototype {
  return [[MotionEvent builder] mergeFrom:prototype];
}
- (MotionEventBuilder*) builder {
  return [MotionEvent builder];
}
- (MotionEventBuilder*) toBuilder {
  return [MotionEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
    [output appendFormat:@"%@%@: %d\n", indent, @"type", self.type];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[MotionEvent class]]) {
    return NO;
  }
  MotionEvent *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL MotionEventTypeIsValidValue(MotionEventType value) {
  switch (value) {
    case MotionEventTypeShake:
      return YES;
    default:
      return NO;
  }
}
@interface MotionEventBuilder()
@property (strong) MotionEvent* result;
@end

@implementation MotionEventBuilder
@synthesize result;
- (void) dealloc {
  self.result = nil;
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[MotionEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (MotionEventBuilder*) clear {
  self.result = [[MotionEvent alloc] init];
  return self;
}
- (MotionEventBuilder*) clone {
  return [MotionEvent builderWithPrototype:result];
}
- (MotionEvent*) defaultInstance {
  return [MotionEvent defaultInstance];
}
- (MotionEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (MotionEvent*) buildPartial {
  MotionEvent* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (MotionEventBuilder*) mergeFrom:(MotionEvent*) other {
  if (other == [MotionEvent defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (MotionEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (MotionEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        MotionEventType value = (MotionEventType)[input readEnum];
        if (MotionEventTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return result.hasType;
}
- (MotionEventType) type {
  return result.type;
}
- (MotionEventBuilder*) setType:(MotionEventType) value {
  result.hasType = YES;
  result.type = value;
  return self;
}
- (MotionEventBuilder*) clearType {
  result.hasType = NO;
  result.type = MotionEventTypeShake;
  return self;
}
@end

@interface KeypressEvent ()
@property KeypressEventState state;
@property SInt32 keycode;
@end

@implementation KeypressEvent

- (BOOL) hasState {
  return !!hasState_;
}
- (void) setHasState:(BOOL) value_ {
  hasState_ = !!value_;
}
@synthesize state;
- (BOOL) hasKeycode {
  return !!hasKeycode_;
}
- (void) setHasKeycode:(BOOL) value_ {
  hasKeycode_ = !!value_;
}
@synthesize keycode;
- (void) dealloc {
}
- (id) init {
  if ((self = [super init])) {
    self.state = KeypressEventStateDown;
    self.keycode = 0;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return KeypressEvent_event;
}
static KeypressEvent* defaultKeypressEventInstance = nil;
+ (void) initialize {
  if (self == [KeypressEvent class]) {
    defaultKeypressEventInstance = [[KeypressEvent alloc] init];
  }
}
+ (KeypressEvent*) defaultInstance {
  return defaultKeypressEventInstance;
}
- (KeypressEvent*) defaultInstance {
  return defaultKeypressEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasState) {
    return NO;
  }
  if (!self.hasKeycode) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasState) {
    [output writeEnum:1 value:self.state];
  }
  if (self.hasKeycode) {
    [output writeInt32:2 value:self.keycode];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasState) {
    size_ += computeEnumSize(1, self.state);
  }
  if (self.hasKeycode) {
    size_ += computeInt32Size(2, self.keycode);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (KeypressEvent*) parseFromData:(NSData*) data {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromData:data] build];
}
+ (KeypressEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (KeypressEvent*) parseFromInputStream:(NSInputStream*) input {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromInputStream:input] build];
}
+ (KeypressEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (KeypressEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromCodedInputStream:input] build];
}
+ (KeypressEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (KeypressEventBuilder*) builder {
  return [[KeypressEventBuilder alloc] init];
}
+ (KeypressEventBuilder*) builderWithPrototype:(KeypressEvent*) prototype {
  return [[KeypressEvent builder] mergeFrom:prototype];
}
- (KeypressEventBuilder*) builder {
  return [KeypressEvent builder];
}
- (KeypressEventBuilder*) toBuilder {
  return [KeypressEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasState) {
    [output appendFormat:@"%@%@: %d\n", indent, @"state", self.state];
  }
  if (self.hasKeycode) {
    [output appendFormat:@"%@%@: %@\n", indent, @"keycode", [NSNumber numberWithInteger:self.keycode]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[KeypressEvent class]]) {
    return NO;
  }
  KeypressEvent *otherMessage = other;
  return
      self.hasState == otherMessage.hasState &&
      (!self.hasState || self.state == otherMessage.state) &&
      self.hasKeycode == otherMessage.hasKeycode &&
      (!self.hasKeycode || self.keycode == otherMessage.keycode) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasState) {
    hashCode = hashCode * 31 + self.state;
  }
  if (self.hasKeycode) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.keycode] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL KeypressEventStateIsValidValue(KeypressEventState value) {
  switch (value) {
    case KeypressEventStateDown:
    case KeypressEventStateUp:
      return YES;
    default:
      return NO;
  }
}
@interface KeypressEventBuilder()
@property (strong) KeypressEvent* result;
@end

@implementation KeypressEventBuilder
@synthesize result;
- (void) dealloc {
  self.result = nil;
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[KeypressEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (KeypressEventBuilder*) clear {
  self.result = [[KeypressEvent alloc] init];
  return self;
}
- (KeypressEventBuilder*) clone {
  return [KeypressEvent builderWithPrototype:result];
}
- (KeypressEvent*) defaultInstance {
  return [KeypressEvent defaultInstance];
}
- (KeypressEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (KeypressEvent*) buildPartial {
  KeypressEvent* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (KeypressEventBuilder*) mergeFrom:(KeypressEvent*) other {
  if (other == [KeypressEvent defaultInstance]) {
    return self;
  }
  if (other.hasState) {
    [self setState:other.state];
  }
  if (other.hasKeycode) {
    [self setKeycode:other.keycode];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (KeypressEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (KeypressEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        KeypressEventState value = (KeypressEventState)[input readEnum];
        if (KeypressEventStateIsValidValue(value)) {
          [self setState:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 16: {
        [self setKeycode:[input readInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasState {
  return result.hasState;
}
- (KeypressEventState) state {
  return result.state;
}
- (KeypressEventBuilder*) setState:(KeypressEventState) value {
  result.hasState = YES;
  result.state = value;
  return self;
}
- (KeypressEventBuilder*) clearState {
  result.hasState = NO;
  result.state = KeypressEventStateDown;
  return self;
}
- (BOOL) hasKeycode {
  return result.hasKeycode;
}
- (SInt32) keycode {
  return result.keycode;
}
- (KeypressEventBuilder*) setKeycode:(SInt32) value {
  result.hasKeycode = YES;
  result.keycode = value;
  return self;
}
- (KeypressEventBuilder*) clearKeycode {
  result.hasKeycode = NO;
  result.keycode = 0;
  return self;
}
@end

@interface GestureEvent ()
@property Float32 locationX;
@property Float32 locationY;
@property Float32 trackareaWidth;
@property Float32 trackareaHeight;
@property GestureEventType type;
@property GestureEventState state;
@property SInt32 tapCount;
@property Float32 pinchScale;
@property Float32 pinchVelocity;
@property Float32 panTranslationX;
@property Float32 panTranslationY;
@property Float32 panVelocityX;
@property Float32 panVelocityY;
@property GestureEventSwipeDirection swipeDirection;
@property Float32 rotationAngle;
@property Float32 rotationVelocity;
@property SInt64 pressDuration;
@property GestureEventCircleDirection circleDirection;
@end

@implementation GestureEvent

- (BOOL) hasLocationX {
  return !!hasLocationX_;
}
- (void) setHasLocationX:(BOOL) value_ {
  hasLocationX_ = !!value_;
}
@synthesize locationX;
- (BOOL) hasLocationY {
  return !!hasLocationY_;
}
- (void) setHasLocationY:(BOOL) value_ {
  hasLocationY_ = !!value_;
}
@synthesize locationY;
- (BOOL) hasTrackareaWidth {
  return !!hasTrackareaWidth_;
}
- (void) setHasTrackareaWidth:(BOOL) value_ {
  hasTrackareaWidth_ = !!value_;
}
@synthesize trackareaWidth;
- (BOOL) hasTrackareaHeight {
  return !!hasTrackareaHeight_;
}
- (void) setHasTrackareaHeight:(BOOL) value_ {
  hasTrackareaHeight_ = !!value_;
}
@synthesize trackareaHeight;
- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasState {
  return !!hasState_;
}
- (void) setHasState:(BOOL) value_ {
  hasState_ = !!value_;
}
@synthesize state;
- (BOOL) hasTapCount {
  return !!hasTapCount_;
}
- (void) setHasTapCount:(BOOL) value_ {
  hasTapCount_ = !!value_;
}
@synthesize tapCount;
- (BOOL) hasPinchScale {
  return !!hasPinchScale_;
}
- (void) setHasPinchScale:(BOOL) value_ {
  hasPinchScale_ = !!value_;
}
@synthesize pinchScale;
- (BOOL) hasPinchVelocity {
  return !!hasPinchVelocity_;
}
- (void) setHasPinchVelocity:(BOOL) value_ {
  hasPinchVelocity_ = !!value_;
}
@synthesize pinchVelocity;
- (BOOL) hasPanTranslationX {
  return !!hasPanTranslationX_;
}
- (void) setHasPanTranslationX:(BOOL) value_ {
  hasPanTranslationX_ = !!value_;
}
@synthesize panTranslationX;
- (BOOL) hasPanTranslationY {
  return !!hasPanTranslationY_;
}
- (void) setHasPanTranslationY:(BOOL) value_ {
  hasPanTranslationY_ = !!value_;
}
@synthesize panTranslationY;
- (BOOL) hasPanVelocityX {
  return !!hasPanVelocityX_;
}
- (void) setHasPanVelocityX:(BOOL) value_ {
  hasPanVelocityX_ = !!value_;
}
@synthesize panVelocityX;
- (BOOL) hasPanVelocityY {
  return !!hasPanVelocityY_;
}
- (void) setHasPanVelocityY:(BOOL) value_ {
  hasPanVelocityY_ = !!value_;
}
@synthesize panVelocityY;
- (BOOL) hasSwipeDirection {
  return !!hasSwipeDirection_;
}
- (void) setHasSwipeDirection:(BOOL) value_ {
  hasSwipeDirection_ = !!value_;
}
@synthesize swipeDirection;
- (BOOL) hasRotationAngle {
  return !!hasRotationAngle_;
}
- (void) setHasRotationAngle:(BOOL) value_ {
  hasRotationAngle_ = !!value_;
}
@synthesize rotationAngle;
- (BOOL) hasRotationVelocity {
  return !!hasRotationVelocity_;
}
- (void) setHasRotationVelocity:(BOOL) value_ {
  hasRotationVelocity_ = !!value_;
}
@synthesize rotationVelocity;
- (BOOL) hasPressDuration {
  return !!hasPressDuration_;
}
- (void) setHasPressDuration:(BOOL) value_ {
  hasPressDuration_ = !!value_;
}
@synthesize pressDuration;
- (BOOL) hasCircleDirection {
  return !!hasCircleDirection_;
}
- (void) setHasCircleDirection:(BOOL) value_ {
  hasCircleDirection_ = !!value_;
}
@synthesize circleDirection;
- (void) dealloc {
}
- (id) init {
  if ((self = [super init])) {
    self.locationX = 0;
    self.locationY = 0;
    self.trackareaWidth = 0;
    self.trackareaHeight = 0;
    self.type = GestureEventTypeTap;
    self.state = GestureEventStatePossible;
    self.tapCount = 0;
    self.pinchScale = 0;
    self.pinchVelocity = 0;
    self.panTranslationX = 0;
    self.panTranslationY = 0;
    self.panVelocityX = 0;
    self.panVelocityY = 0;
    self.swipeDirection = GestureEventSwipeDirectionRight;
    self.rotationAngle = 0;
    self.rotationVelocity = 0;
    self.pressDuration = 0L;
    self.circleDirection = GestureEventCircleDirectionClockwise;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return GestureEvent_event;
}
static GestureEvent* defaultGestureEventInstance = nil;
+ (void) initialize {
  if (self == [GestureEvent class]) {
    defaultGestureEventInstance = [[GestureEvent alloc] init];
  }
}
+ (GestureEvent*) defaultInstance {
  return defaultGestureEventInstance;
}
- (GestureEvent*) defaultInstance {
  return defaultGestureEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasLocationX) {
    return NO;
  }
  if (!self.hasLocationY) {
    return NO;
  }
  if (!self.hasTrackareaWidth) {
    return NO;
  }
  if (!self.hasTrackareaHeight) {
    return NO;
  }
  if (!self.hasType) {
    return NO;
  }
  if (!self.hasState) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasLocationX) {
    [output writeFloat:1 value:self.locationX];
  }
  if (self.hasLocationY) {
    [output writeFloat:2 value:self.locationY];
  }
  if (self.hasTrackareaWidth) {
    [output writeFloat:3 value:self.trackareaWidth];
  }
  if (self.hasTrackareaHeight) {
    [output writeFloat:4 value:self.trackareaHeight];
  }
  if (self.hasType) {
    [output writeEnum:5 value:self.type];
  }
  if (self.hasState) {
    [output writeEnum:6 value:self.state];
  }
  if (self.hasTapCount) {
    [output writeInt32:7 value:self.tapCount];
  }
  if (self.hasPinchScale) {
    [output writeFloat:8 value:self.pinchScale];
  }
  if (self.hasPinchVelocity) {
    [output writeFloat:9 value:self.pinchVelocity];
  }
  if (self.hasPanTranslationX) {
    [output writeFloat:10 value:self.panTranslationX];
  }
  if (self.hasPanTranslationY) {
    [output writeFloat:11 value:self.panTranslationY];
  }
  if (self.hasPanVelocityX) {
    [output writeFloat:12 value:self.panVelocityX];
  }
  if (self.hasPanVelocityY) {
    [output writeFloat:13 value:self.panVelocityY];
  }
  if (self.hasSwipeDirection) {
    [output writeEnum:14 value:self.swipeDirection];
  }
  if (self.hasRotationAngle) {
    [output writeFloat:15 value:self.rotationAngle];
  }
  if (self.hasRotationVelocity) {
    [output writeFloat:16 value:self.rotationVelocity];
  }
  if (self.hasPressDuration) {
    [output writeInt64:17 value:self.pressDuration];
  }
  if (self.hasCircleDirection) {
    [output writeEnum:18 value:self.circleDirection];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasLocationX) {
    size_ += computeFloatSize(1, self.locationX);
  }
  if (self.hasLocationY) {
    size_ += computeFloatSize(2, self.locationY);
  }
  if (self.hasTrackareaWidth) {
    size_ += computeFloatSize(3, self.trackareaWidth);
  }
  if (self.hasTrackareaHeight) {
    size_ += computeFloatSize(4, self.trackareaHeight);
  }
  if (self.hasType) {
    size_ += computeEnumSize(5, self.type);
  }
  if (self.hasState) {
    size_ += computeEnumSize(6, self.state);
  }
  if (self.hasTapCount) {
    size_ += computeInt32Size(7, self.tapCount);
  }
  if (self.hasPinchScale) {
    size_ += computeFloatSize(8, self.pinchScale);
  }
  if (self.hasPinchVelocity) {
    size_ += computeFloatSize(9, self.pinchVelocity);
  }
  if (self.hasPanTranslationX) {
    size_ += computeFloatSize(10, self.panTranslationX);
  }
  if (self.hasPanTranslationY) {
    size_ += computeFloatSize(11, self.panTranslationY);
  }
  if (self.hasPanVelocityX) {
    size_ += computeFloatSize(12, self.panVelocityX);
  }
  if (self.hasPanVelocityY) {
    size_ += computeFloatSize(13, self.panVelocityY);
  }
  if (self.hasSwipeDirection) {
    size_ += computeEnumSize(14, self.swipeDirection);
  }
  if (self.hasRotationAngle) {
    size_ += computeFloatSize(15, self.rotationAngle);
  }
  if (self.hasRotationVelocity) {
    size_ += computeFloatSize(16, self.rotationVelocity);
  }
  if (self.hasPressDuration) {
    size_ += computeInt64Size(17, self.pressDuration);
  }
  if (self.hasCircleDirection) {
    size_ += computeEnumSize(18, self.circleDirection);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (GestureEvent*) parseFromData:(NSData*) data {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromData:data] build];
}
+ (GestureEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (GestureEvent*) parseFromInputStream:(NSInputStream*) input {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromInputStream:input] build];
}
+ (GestureEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (GestureEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromCodedInputStream:input] build];
}
+ (GestureEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (GestureEventBuilder*) builder {
  return [[GestureEventBuilder alloc] init];
}
+ (GestureEventBuilder*) builderWithPrototype:(GestureEvent*) prototype {
  return [[GestureEvent builder] mergeFrom:prototype];
}
- (GestureEventBuilder*) builder {
  return [GestureEvent builder];
}
- (GestureEventBuilder*) toBuilder {
  return [GestureEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasLocationX) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationX", [NSNumber numberWithFloat:self.locationX]];
  }
  if (self.hasLocationY) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationY", [NSNumber numberWithFloat:self.locationY]];
  }
  if (self.hasTrackareaWidth) {
    [output appendFormat:@"%@%@: %@\n", indent, @"trackareaWidth", [NSNumber numberWithFloat:self.trackareaWidth]];
  }
  if (self.hasTrackareaHeight) {
    [output appendFormat:@"%@%@: %@\n", indent, @"trackareaHeight", [NSNumber numberWithFloat:self.trackareaHeight]];
  }
  if (self.hasType) {
    [output appendFormat:@"%@%@: %d\n", indent, @"type", self.type];
  }
  if (self.hasState) {
    [output appendFormat:@"%@%@: %d\n", indent, @"state", self.state];
  }
  if (self.hasTapCount) {
    [output appendFormat:@"%@%@: %@\n", indent, @"tapCount", [NSNumber numberWithInteger:self.tapCount]];
  }
  if (self.hasPinchScale) {
    [output appendFormat:@"%@%@: %@\n", indent, @"pinchScale", [NSNumber numberWithFloat:self.pinchScale]];
  }
  if (self.hasPinchVelocity) {
    [output appendFormat:@"%@%@: %@\n", indent, @"pinchVelocity", [NSNumber numberWithFloat:self.pinchVelocity]];
  }
  if (self.hasPanTranslationX) {
    [output appendFormat:@"%@%@: %@\n", indent, @"panTranslationX", [NSNumber numberWithFloat:self.panTranslationX]];
  }
  if (self.hasPanTranslationY) {
    [output appendFormat:@"%@%@: %@\n", indent, @"panTranslationY", [NSNumber numberWithFloat:self.panTranslationY]];
  }
  if (self.hasPanVelocityX) {
    [output appendFormat:@"%@%@: %@\n", indent, @"panVelocityX", [NSNumber numberWithFloat:self.panVelocityX]];
  }
  if (self.hasPanVelocityY) {
    [output appendFormat:@"%@%@: %@\n", indent, @"panVelocityY", [NSNumber numberWithFloat:self.panVelocityY]];
  }
  if (self.hasSwipeDirection) {
    [output appendFormat:@"%@%@: %d\n", indent, @"swipeDirection", self.swipeDirection];
  }
  if (self.hasRotationAngle) {
    [output appendFormat:@"%@%@: %@\n", indent, @"rotationAngle", [NSNumber numberWithFloat:self.rotationAngle]];
  }
  if (self.hasRotationVelocity) {
    [output appendFormat:@"%@%@: %@\n", indent, @"rotationVelocity", [NSNumber numberWithFloat:self.rotationVelocity]];
  }
  if (self.hasPressDuration) {
    [output appendFormat:@"%@%@: %@\n", indent, @"pressDuration", [NSNumber numberWithLongLong:self.pressDuration]];
  }
  if (self.hasCircleDirection) {
    [output appendFormat:@"%@%@: %d\n", indent, @"circleDirection", self.circleDirection];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[GestureEvent class]]) {
    return NO;
  }
  GestureEvent *otherMessage = other;
  return
      self.hasLocationX == otherMessage.hasLocationX &&
      (!self.hasLocationX || self.locationX == otherMessage.locationX) &&
      self.hasLocationY == otherMessage.hasLocationY &&
      (!self.hasLocationY || self.locationY == otherMessage.locationY) &&
      self.hasTrackareaWidth == otherMessage.hasTrackareaWidth &&
      (!self.hasTrackareaWidth || self.trackareaWidth == otherMessage.trackareaWidth) &&
      self.hasTrackareaHeight == otherMessage.hasTrackareaHeight &&
      (!self.hasTrackareaHeight || self.trackareaHeight == otherMessage.trackareaHeight) &&
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasState == otherMessage.hasState &&
      (!self.hasState || self.state == otherMessage.state) &&
      self.hasTapCount == otherMessage.hasTapCount &&
      (!self.hasTapCount || self.tapCount == otherMessage.tapCount) &&
      self.hasPinchScale == otherMessage.hasPinchScale &&
      (!self.hasPinchScale || self.pinchScale == otherMessage.pinchScale) &&
      self.hasPinchVelocity == otherMessage.hasPinchVelocity &&
      (!self.hasPinchVelocity || self.pinchVelocity == otherMessage.pinchVelocity) &&
      self.hasPanTranslationX == otherMessage.hasPanTranslationX &&
      (!self.hasPanTranslationX || self.panTranslationX == otherMessage.panTranslationX) &&
      self.hasPanTranslationY == otherMessage.hasPanTranslationY &&
      (!self.hasPanTranslationY || self.panTranslationY == otherMessage.panTranslationY) &&
      self.hasPanVelocityX == otherMessage.hasPanVelocityX &&
      (!self.hasPanVelocityX || self.panVelocityX == otherMessage.panVelocityX) &&
      self.hasPanVelocityY == otherMessage.hasPanVelocityY &&
      (!self.hasPanVelocityY || self.panVelocityY == otherMessage.panVelocityY) &&
      self.hasSwipeDirection == otherMessage.hasSwipeDirection &&
      (!self.hasSwipeDirection || self.swipeDirection == otherMessage.swipeDirection) &&
      self.hasRotationAngle == otherMessage.hasRotationAngle &&
      (!self.hasRotationAngle || self.rotationAngle == otherMessage.rotationAngle) &&
      self.hasRotationVelocity == otherMessage.hasRotationVelocity &&
      (!self.hasRotationVelocity || self.rotationVelocity == otherMessage.rotationVelocity) &&
      self.hasPressDuration == otherMessage.hasPressDuration &&
      (!self.hasPressDuration || self.pressDuration == otherMessage.pressDuration) &&
      self.hasCircleDirection == otherMessage.hasCircleDirection &&
      (!self.hasCircleDirection || self.circleDirection == otherMessage.circleDirection) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasLocationX) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationX] hash];
  }
  if (self.hasLocationY) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationY] hash];
  }
  if (self.hasTrackareaWidth) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.trackareaWidth] hash];
  }
  if (self.hasTrackareaHeight) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.trackareaHeight] hash];
  }
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasState) {
    hashCode = hashCode * 31 + self.state;
  }
  if (self.hasTapCount) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.tapCount] hash];
  }
  if (self.hasPinchScale) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.pinchScale] hash];
  }
  if (self.hasPinchVelocity) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.pinchVelocity] hash];
  }
  if (self.hasPanTranslationX) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.panTranslationX] hash];
  }
  if (self.hasPanTranslationY) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.panTranslationY] hash];
  }
  if (self.hasPanVelocityX) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.panVelocityX] hash];
  }
  if (self.hasPanVelocityY) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.panVelocityY] hash];
  }
  if (self.hasSwipeDirection) {
    hashCode = hashCode * 31 + self.swipeDirection;
  }
  if (self.hasRotationAngle) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.rotationAngle] hash];
  }
  if (self.hasRotationVelocity) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.rotationVelocity] hash];
  }
  if (self.hasPressDuration) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.pressDuration] hash];
  }
  if (self.hasCircleDirection) {
    hashCode = hashCode * 31 + self.circleDirection;
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL GestureEventTypeIsValidValue(GestureEventType value) {
  switch (value) {
    case GestureEventTypeTap:
    case GestureEventTypePinch:
    case GestureEventTypePan:
    case GestureEventTypeSwipe:
    case GestureEventTypeRotation:
    case GestureEventTypeLongpress:
    case GestureEventTypeCircle:
    case GestureEventTypeWave:
      return YES;
    default:
      return NO;
  }
}
BOOL GestureEventStateIsValidValue(GestureEventState value) {
  switch (value) {
    case GestureEventStatePossible:
    case GestureEventStateBegan:
    case GestureEventStateChanged:
    case GestureEventStateEnded:
    case GestureEventStateCancelled:
    case GestureEventStateFailed:
      return YES;
    default:
      return NO;
  }
}
BOOL GestureEventSwipeDirectionIsValidValue(GestureEventSwipeDirection value) {
  switch (value) {
    case GestureEventSwipeDirectionRight:
    case GestureEventSwipeDirectionLeft:
    case GestureEventSwipeDirectionUp:
    case GestureEventSwipeDirectionDown:
    case GestureEventSwipeDirectionForward:
    case GestureEventSwipeDirectionBackward:
      return YES;
    default:
      return NO;
  }
}
BOOL GestureEventCircleDirectionIsValidValue(GestureEventCircleDirection value) {
  switch (value) {
    case GestureEventCircleDirectionClockwise:
    case GestureEventCircleDirectionCounterClockwise:
      return YES;
    default:
      return NO;
  }
}
@interface GestureEventBuilder()
@property (strong) GestureEvent* result;
@end

@implementation GestureEventBuilder
@synthesize result;
- (void) dealloc {
  self.result = nil;
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[GestureEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (GestureEventBuilder*) clear {
  self.result = [[GestureEvent alloc] init];
  return self;
}
- (GestureEventBuilder*) clone {
  return [GestureEvent builderWithPrototype:result];
}
- (GestureEvent*) defaultInstance {
  return [GestureEvent defaultInstance];
}
- (GestureEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (GestureEvent*) buildPartial {
  GestureEvent* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (GestureEventBuilder*) mergeFrom:(GestureEvent*) other {
  if (other == [GestureEvent defaultInstance]) {
    return self;
  }
  if (other.hasLocationX) {
    [self setLocationX:other.locationX];
  }
  if (other.hasLocationY) {
    [self setLocationY:other.locationY];
  }
  if (other.hasTrackareaWidth) {
    [self setTrackareaWidth:other.trackareaWidth];
  }
  if (other.hasTrackareaHeight) {
    [self setTrackareaHeight:other.trackareaHeight];
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasState) {
    [self setState:other.state];
  }
  if (other.hasTapCount) {
    [self setTapCount:other.tapCount];
  }
  if (other.hasPinchScale) {
    [self setPinchScale:other.pinchScale];
  }
  if (other.hasPinchVelocity) {
    [self setPinchVelocity:other.pinchVelocity];
  }
  if (other.hasPanTranslationX) {
    [self setPanTranslationX:other.panTranslationX];
  }
  if (other.hasPanTranslationY) {
    [self setPanTranslationY:other.panTranslationY];
  }
  if (other.hasPanVelocityX) {
    [self setPanVelocityX:other.panVelocityX];
  }
  if (other.hasPanVelocityY) {
    [self setPanVelocityY:other.panVelocityY];
  }
  if (other.hasSwipeDirection) {
    [self setSwipeDirection:other.swipeDirection];
  }
  if (other.hasRotationAngle) {
    [self setRotationAngle:other.rotationAngle];
  }
  if (other.hasRotationVelocity) {
    [self setRotationVelocity:other.rotationVelocity];
  }
  if (other.hasPressDuration) {
    [self setPressDuration:other.pressDuration];
  }
  if (other.hasCircleDirection) {
    [self setCircleDirection:other.circleDirection];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (GestureEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (GestureEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 13: {
        [self setLocationX:[input readFloat]];
        break;
      }
      case 21: {
        [self setLocationY:[input readFloat]];
        break;
      }
      case 29: {
        [self setTrackareaWidth:[input readFloat]];
        break;
      }
      case 37: {
        [self setTrackareaHeight:[input readFloat]];
        break;
      }
      case 40: {
        GestureEventType value = (GestureEventType)[input readEnum];
        if (GestureEventTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:5 value:value];
        }
        break;
      }
      case 48: {
        GestureEventState value = (GestureEventState)[input readEnum];
        if (GestureEventStateIsValidValue(value)) {
          [self setState:value];
        } else {
          [unknownFields mergeVarintField:6 value:value];
        }
        break;
      }
      case 56: {
        [self setTapCount:[input readInt32]];
        break;
      }
      case 69: {
        [self setPinchScale:[input readFloat]];
        break;
      }
      case 77: {
        [self setPinchVelocity:[input readFloat]];
        break;
      }
      case 85: {
        [self setPanTranslationX:[input readFloat]];
        break;
      }
      case 93: {
        [self setPanTranslationY:[input readFloat]];
        break;
      }
      case 101: {
        [self setPanVelocityX:[input readFloat]];
        break;
      }
      case 109: {
        [self setPanVelocityY:[input readFloat]];
        break;
      }
      case 112: {
        GestureEventSwipeDirection value = (GestureEventSwipeDirection)[input readEnum];
        if (GestureEventSwipeDirectionIsValidValue(value)) {
          [self setSwipeDirection:value];
        } else {
          [unknownFields mergeVarintField:14 value:value];
        }
        break;
      }
      case 125: {
        [self setRotationAngle:[input readFloat]];
        break;
      }
      case 133: {
        [self setRotationVelocity:[input readFloat]];
        break;
      }
      case 136: {
        [self setPressDuration:[input readInt64]];
        break;
      }
      case 144: {
        GestureEventCircleDirection value = (GestureEventCircleDirection)[input readEnum];
        if (GestureEventCircleDirectionIsValidValue(value)) {
          [self setCircleDirection:value];
        } else {
          [unknownFields mergeVarintField:18 value:value];
        }
        break;
      }
    }
  }
}
- (BOOL) hasLocationX {
  return result.hasLocationX;
}
- (Float32) locationX {
  return result.locationX;
}
- (GestureEventBuilder*) setLocationX:(Float32) value {
  result.hasLocationX = YES;
  result.locationX = value;
  return self;
}
- (GestureEventBuilder*) clearLocationX {
  result.hasLocationX = NO;
  result.locationX = 0;
  return self;
}
- (BOOL) hasLocationY {
  return result.hasLocationY;
}
- (Float32) locationY {
  return result.locationY;
}
- (GestureEventBuilder*) setLocationY:(Float32) value {
  result.hasLocationY = YES;
  result.locationY = value;
  return self;
}
- (GestureEventBuilder*) clearLocationY {
  result.hasLocationY = NO;
  result.locationY = 0;
  return self;
}
- (BOOL) hasTrackareaWidth {
  return result.hasTrackareaWidth;
}
- (Float32) trackareaWidth {
  return result.trackareaWidth;
}
- (GestureEventBuilder*) setTrackareaWidth:(Float32) value {
  result.hasTrackareaWidth = YES;
  result.trackareaWidth = value;
  return self;
}
- (GestureEventBuilder*) clearTrackareaWidth {
  result.hasTrackareaWidth = NO;
  result.trackareaWidth = 0;
  return self;
}
- (BOOL) hasTrackareaHeight {
  return result.hasTrackareaHeight;
}
- (Float32) trackareaHeight {
  return result.trackareaHeight;
}
- (GestureEventBuilder*) setTrackareaHeight:(Float32) value {
  result.hasTrackareaHeight = YES;
  result.trackareaHeight = value;
  return self;
}
- (GestureEventBuilder*) clearTrackareaHeight {
  result.hasTrackareaHeight = NO;
  result.trackareaHeight = 0;
  return self;
}
- (BOOL) hasType {
  return result.hasType;
}
- (GestureEventType) type {
  return result.type;
}
- (GestureEventBuilder*) setType:(GestureEventType) value {
  result.hasType = YES;
  result.type = value;
  return self;
}
- (GestureEventBuilder*) clearType {
  result.hasType = NO;
  result.type = GestureEventTypeTap;
  return self;
}
- (BOOL) hasState {
  return result.hasState;
}
- (GestureEventState) state {
  return result.state;
}
- (GestureEventBuilder*) setState:(GestureEventState) value {
  result.hasState = YES;
  result.state = value;
  return self;
}
- (GestureEventBuilder*) clearState {
  result.hasState = NO;
  result.state = GestureEventStatePossible;
  return self;
}
- (BOOL) hasTapCount {
  return result.hasTapCount;
}
- (SInt32) tapCount {
  return result.tapCount;
}
- (GestureEventBuilder*) setTapCount:(SInt32) value {
  result.hasTapCount = YES;
  result.tapCount = value;
  return self;
}
- (GestureEventBuilder*) clearTapCount {
  result.hasTapCount = NO;
  result.tapCount = 0;
  return self;
}
- (BOOL) hasPinchScale {
  return result.hasPinchScale;
}
- (Float32) pinchScale {
  return result.pinchScale;
}
- (GestureEventBuilder*) setPinchScale:(Float32) value {
  result.hasPinchScale = YES;
  result.pinchScale = value;
  return self;
}
- (GestureEventBuilder*) clearPinchScale {
  result.hasPinchScale = NO;
  result.pinchScale = 0;
  return self;
}
- (BOOL) hasPinchVelocity {
  return result.hasPinchVelocity;
}
- (Float32) pinchVelocity {
  return result.pinchVelocity;
}
- (GestureEventBuilder*) setPinchVelocity:(Float32) value {
  result.hasPinchVelocity = YES;
  result.pinchVelocity = value;
  return self;
}
- (GestureEventBuilder*) clearPinchVelocity {
  result.hasPinchVelocity = NO;
  result.pinchVelocity = 0;
  return self;
}
- (BOOL) hasPanTranslationX {
  return result.hasPanTranslationX;
}
- (Float32) panTranslationX {
  return result.panTranslationX;
}
- (GestureEventBuilder*) setPanTranslationX:(Float32) value {
  result.hasPanTranslationX = YES;
  result.panTranslationX = value;
  return self;
}
- (GestureEventBuilder*) clearPanTranslationX {
  result.hasPanTranslationX = NO;
  result.panTranslationX = 0;
  return self;
}
- (BOOL) hasPanTranslationY {
  return result.hasPanTranslationY;
}
- (Float32) panTranslationY {
  return result.panTranslationY;
}
- (GestureEventBuilder*) setPanTranslationY:(Float32) value {
  result.hasPanTranslationY = YES;
  result.panTranslationY = value;
  return self;
}
- (GestureEventBuilder*) clearPanTranslationY {
  result.hasPanTranslationY = NO;
  result.panTranslationY = 0;
  return self;
}
- (BOOL) hasPanVelocityX {
  return result.hasPanVelocityX;
}
- (Float32) panVelocityX {
  return result.panVelocityX;
}
- (GestureEventBuilder*) setPanVelocityX:(Float32) value {
  result.hasPanVelocityX = YES;
  result.panVelocityX = value;
  return self;
}
- (GestureEventBuilder*) clearPanVelocityX {
  result.hasPanVelocityX = NO;
  result.panVelocityX = 0;
  return self;
}
- (BOOL) hasPanVelocityY {
  return result.hasPanVelocityY;
}
- (Float32) panVelocityY {
  return result.panVelocityY;
}
- (GestureEventBuilder*) setPanVelocityY:(Float32) value {
  result.hasPanVelocityY = YES;
  result.panVelocityY = value;
  return self;
}
- (GestureEventBuilder*) clearPanVelocityY {
  result.hasPanVelocityY = NO;
  result.panVelocityY = 0;
  return self;
}
- (BOOL) hasSwipeDirection {
  return result.hasSwipeDirection;
}
- (GestureEventSwipeDirection) swipeDirection {
  return result.swipeDirection;
}
- (GestureEventBuilder*) setSwipeDirection:(GestureEventSwipeDirection) value {
  result.hasSwipeDirection = YES;
  result.swipeDirection = value;
  return self;
}
- (GestureEventBuilder*) clearSwipeDirection {
  result.hasSwipeDirection = NO;
  result.swipeDirection = GestureEventSwipeDirectionRight;
  return self;
}
- (BOOL) hasRotationAngle {
  return result.hasRotationAngle;
}
- (Float32) rotationAngle {
  return result.rotationAngle;
}
- (GestureEventBuilder*) setRotationAngle:(Float32) value {
  result.hasRotationAngle = YES;
  result.rotationAngle = value;
  return self;
}
- (GestureEventBuilder*) clearRotationAngle {
  result.hasRotationAngle = NO;
  result.rotationAngle = 0;
  return self;
}
- (BOOL) hasRotationVelocity {
  return result.hasRotationVelocity;
}
- (Float32) rotationVelocity {
  return result.rotationVelocity;
}
- (GestureEventBuilder*) setRotationVelocity:(Float32) value {
  result.hasRotationVelocity = YES;
  result.rotationVelocity = value;
  return self;
}
- (GestureEventBuilder*) clearRotationVelocity {
  result.hasRotationVelocity = NO;
  result.rotationVelocity = 0;
  return self;
}
- (BOOL) hasPressDuration {
  return result.hasPressDuration;
}
- (SInt64) pressDuration {
  return result.pressDuration;
}
- (GestureEventBuilder*) setPressDuration:(SInt64) value {
  result.hasPressDuration = YES;
  result.pressDuration = value;
  return self;
}
- (GestureEventBuilder*) clearPressDuration {
  result.hasPressDuration = NO;
  result.pressDuration = 0L;
  return self;
}
- (BOOL) hasCircleDirection {
  return result.hasCircleDirection;
}
- (GestureEventCircleDirection) circleDirection {
  return result.circleDirection;
}
- (GestureEventBuilder*) setCircleDirection:(GestureEventCircleDirection) value {
  result.hasCircleDirection = YES;
  result.circleDirection = value;
  return self;
}
- (GestureEventBuilder*) clearCircleDirection {
  result.hasCircleDirection = NO;
  result.circleDirection = GestureEventCircleDirectionClockwise;
  return self;
}
@end

@interface HandMotionEvent ()
@property Float32 locationX;
@property Float32 locationY;
@property Float32 trackareaWidth;
@property Float32 trackareaHeight;
@property HandMotionEventState state;
@property Phase phase;
@property Float32 pitch;
@property Float32 yaw;
@property Float32 roll;
@end

@implementation HandMotionEvent

- (BOOL) hasLocationX {
  return !!hasLocationX_;
}
- (void) setHasLocationX:(BOOL) value_ {
  hasLocationX_ = !!value_;
}
@synthesize locationX;
- (BOOL) hasLocationY {
  return !!hasLocationY_;
}
- (void) setHasLocationY:(BOOL) value_ {
  hasLocationY_ = !!value_;
}
@synthesize locationY;
- (BOOL) hasTrackareaWidth {
  return !!hasTrackareaWidth_;
}
- (void) setHasTrackareaWidth:(BOOL) value_ {
  hasTrackareaWidth_ = !!value_;
}
@synthesize trackareaWidth;
- (BOOL) hasTrackareaHeight {
  return !!hasTrackareaHeight_;
}
- (void) setHasTrackareaHeight:(BOOL) value_ {
  hasTrackareaHeight_ = !!value_;
}
@synthesize trackareaHeight;
- (BOOL) hasState {
  return !!hasState_;
}
- (void) setHasState:(BOOL) value_ {
  hasState_ = !!value_;
}
@synthesize state;
- (BOOL) hasPhase {
  return !!hasPhase_;
}
- (void) setHasPhase:(BOOL) value_ {
  hasPhase_ = !!value_;
}
@synthesize phase;
- (BOOL) hasPitch {
  return !!hasPitch_;
}
- (void) setHasPitch:(BOOL) value_ {
  hasPitch_ = !!value_;
}
@synthesize pitch;
- (BOOL) hasYaw {
  return !!hasYaw_;
}
- (void) setHasYaw:(BOOL) value_ {
  hasYaw_ = !!value_;
}
@synthesize yaw;
- (BOOL) hasRoll {
  return !!hasRoll_;
}
- (void) setHasRoll:(BOOL) value_ {
  hasRoll_ = !!value_;
}
@synthesize roll;
- (void) dealloc {
}
- (id) init {
  if ((self = [super init])) {
    self.locationX = 0;
    self.locationY = 0;
    self.trackareaWidth = 0;
    self.trackareaHeight = 0;
    self.state = HandMotionEventStateOpen;
    self.phase = PhaseBegan;
    self.pitch = 0;
    self.yaw = 0;
    self.roll = 0;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return HandMotionEvent_event;
}
static HandMotionEvent* defaultHandMotionEventInstance = nil;
+ (void) initialize {
  if (self == [HandMotionEvent class]) {
    defaultHandMotionEventInstance = [[HandMotionEvent alloc] init];
  }
}
+ (HandMotionEvent*) defaultInstance {
  return defaultHandMotionEventInstance;
}
- (HandMotionEvent*) defaultInstance {
  return defaultHandMotionEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasLocationX) {
    return NO;
  }
  if (!self.hasLocationY) {
    return NO;
  }
  if (!self.hasTrackareaWidth) {
    return NO;
  }
  if (!self.hasTrackareaHeight) {
    return NO;
  }
  if (!self.hasState) {
    return NO;
  }
  if (!self.hasPhase) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasLocationX) {
    [output writeFloat:1 value:self.locationX];
  }
  if (self.hasLocationY) {
    [output writeFloat:2 value:self.locationY];
  }
  if (self.hasTrackareaWidth) {
    [output writeFloat:3 value:self.trackareaWidth];
  }
  if (self.hasTrackareaHeight) {
    [output writeFloat:4 value:self.trackareaHeight];
  }
  if (self.hasState) {
    [output writeEnum:5 value:self.state];
  }
  if (self.hasPhase) {
    [output writeEnum:6 value:self.phase];
  }
  if (self.hasPitch) {
    [output writeFloat:7 value:self.pitch];
  }
  if (self.hasYaw) {
    [output writeFloat:8 value:self.yaw];
  }
  if (self.hasRoll) {
    [output writeFloat:9 value:self.roll];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasLocationX) {
    size_ += computeFloatSize(1, self.locationX);
  }
  if (self.hasLocationY) {
    size_ += computeFloatSize(2, self.locationY);
  }
  if (self.hasTrackareaWidth) {
    size_ += computeFloatSize(3, self.trackareaWidth);
  }
  if (self.hasTrackareaHeight) {
    size_ += computeFloatSize(4, self.trackareaHeight);
  }
  if (self.hasState) {
    size_ += computeEnumSize(5, self.state);
  }
  if (self.hasPhase) {
    size_ += computeEnumSize(6, self.phase);
  }
  if (self.hasPitch) {
    size_ += computeFloatSize(7, self.pitch);
  }
  if (self.hasYaw) {
    size_ += computeFloatSize(8, self.yaw);
  }
  if (self.hasRoll) {
    size_ += computeFloatSize(9, self.roll);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (HandMotionEvent*) parseFromData:(NSData*) data {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromData:data] build];
}
+ (HandMotionEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (HandMotionEvent*) parseFromInputStream:(NSInputStream*) input {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromInputStream:input] build];
}
+ (HandMotionEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (HandMotionEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromCodedInputStream:input] build];
}
+ (HandMotionEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (HandMotionEventBuilder*) builder {
  return [[HandMotionEventBuilder alloc] init];
}
+ (HandMotionEventBuilder*) builderWithPrototype:(HandMotionEvent*) prototype {
  return [[HandMotionEvent builder] mergeFrom:prototype];
}
- (HandMotionEventBuilder*) builder {
  return [HandMotionEvent builder];
}
- (HandMotionEventBuilder*) toBuilder {
  return [HandMotionEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasLocationX) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationX", [NSNumber numberWithFloat:self.locationX]];
  }
  if (self.hasLocationY) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationY", [NSNumber numberWithFloat:self.locationY]];
  }
  if (self.hasTrackareaWidth) {
    [output appendFormat:@"%@%@: %@\n", indent, @"trackareaWidth", [NSNumber numberWithFloat:self.trackareaWidth]];
  }
  if (self.hasTrackareaHeight) {
    [output appendFormat:@"%@%@: %@\n", indent, @"trackareaHeight", [NSNumber numberWithFloat:self.trackareaHeight]];
  }
  if (self.hasState) {
    [output appendFormat:@"%@%@: %d\n", indent, @"state", self.state];
  }
  if (self.hasPhase) {
    [output appendFormat:@"%@%@: %d\n", indent, @"phase", self.phase];
  }
  if (self.hasPitch) {
    [output appendFormat:@"%@%@: %@\n", indent, @"pitch", [NSNumber numberWithFloat:self.pitch]];
  }
  if (self.hasYaw) {
    [output appendFormat:@"%@%@: %@\n", indent, @"yaw", [NSNumber numberWithFloat:self.yaw]];
  }
  if (self.hasRoll) {
    [output appendFormat:@"%@%@: %@\n", indent, @"roll", [NSNumber numberWithFloat:self.roll]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[HandMotionEvent class]]) {
    return NO;
  }
  HandMotionEvent *otherMessage = other;
  return
      self.hasLocationX == otherMessage.hasLocationX &&
      (!self.hasLocationX || self.locationX == otherMessage.locationX) &&
      self.hasLocationY == otherMessage.hasLocationY &&
      (!self.hasLocationY || self.locationY == otherMessage.locationY) &&
      self.hasTrackareaWidth == otherMessage.hasTrackareaWidth &&
      (!self.hasTrackareaWidth || self.trackareaWidth == otherMessage.trackareaWidth) &&
      self.hasTrackareaHeight == otherMessage.hasTrackareaHeight &&
      (!self.hasTrackareaHeight || self.trackareaHeight == otherMessage.trackareaHeight) &&
      self.hasState == otherMessage.hasState &&
      (!self.hasState || self.state == otherMessage.state) &&
      self.hasPhase == otherMessage.hasPhase &&
      (!self.hasPhase || self.phase == otherMessage.phase) &&
      self.hasPitch == otherMessage.hasPitch &&
      (!self.hasPitch || self.pitch == otherMessage.pitch) &&
      self.hasYaw == otherMessage.hasYaw &&
      (!self.hasYaw || self.yaw == otherMessage.yaw) &&
      self.hasRoll == otherMessage.hasRoll &&
      (!self.hasRoll || self.roll == otherMessage.roll) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasLocationX) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationX] hash];
  }
  if (self.hasLocationY) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationY] hash];
  }
  if (self.hasTrackareaWidth) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.trackareaWidth] hash];
  }
  if (self.hasTrackareaHeight) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.trackareaHeight] hash];
  }
  if (self.hasState) {
    hashCode = hashCode * 31 + self.state;
  }
  if (self.hasPhase) {
    hashCode = hashCode * 31 + self.phase;
  }
  if (self.hasPitch) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.pitch] hash];
  }
  if (self.hasYaw) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.yaw] hash];
  }
  if (self.hasRoll) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.roll] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL HandMotionEventStateIsValidValue(HandMotionEventState value) {
  switch (value) {
    case HandMotionEventStateOpen:
    case HandMotionEventStateGrab:
    case HandMotionEventStatePinch:
      return YES;
    default:
      return NO;
  }
}
@interface HandMotionEventBuilder()
@property (strong) HandMotionEvent* result;
@end

@implementation HandMotionEventBuilder
@synthesize result;
- (void) dealloc {
  self.result = nil;
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[HandMotionEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (HandMotionEventBuilder*) clear {
  self.result = [[HandMotionEvent alloc] init];
  return self;
}
- (HandMotionEventBuilder*) clone {
  return [HandMotionEvent builderWithPrototype:result];
}
- (HandMotionEvent*) defaultInstance {
  return [HandMotionEvent defaultInstance];
}
- (HandMotionEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (HandMotionEvent*) buildPartial {
  HandMotionEvent* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (HandMotionEventBuilder*) mergeFrom:(HandMotionEvent*) other {
  if (other == [HandMotionEvent defaultInstance]) {
    return self;
  }
  if (other.hasLocationX) {
    [self setLocationX:other.locationX];
  }
  if (other.hasLocationY) {
    [self setLocationY:other.locationY];
  }
  if (other.hasTrackareaWidth) {
    [self setTrackareaWidth:other.trackareaWidth];
  }
  if (other.hasTrackareaHeight) {
    [self setTrackareaHeight:other.trackareaHeight];
  }
  if (other.hasState) {
    [self setState:other.state];
  }
  if (other.hasPhase) {
    [self setPhase:other.phase];
  }
  if (other.hasPitch) {
    [self setPitch:other.pitch];
  }
  if (other.hasYaw) {
    [self setYaw:other.yaw];
  }
  if (other.hasRoll) {
    [self setRoll:other.roll];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (HandMotionEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (HandMotionEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 13: {
        [self setLocationX:[input readFloat]];
        break;
      }
      case 21: {
        [self setLocationY:[input readFloat]];
        break;
      }
      case 29: {
        [self setTrackareaWidth:[input readFloat]];
        break;
      }
      case 37: {
        [self setTrackareaHeight:[input readFloat]];
        break;
      }
      case 40: {
        HandMotionEventState value = (HandMotionEventState)[input readEnum];
        if (HandMotionEventStateIsValidValue(value)) {
          [self setState:value];
        } else {
          [unknownFields mergeVarintField:5 value:value];
        }
        break;
      }
      case 48: {
        Phase value = (Phase)[input readEnum];
        if (PhaseIsValidValue(value)) {
          [self setPhase:value];
        } else {
          [unknownFields mergeVarintField:6 value:value];
        }
        break;
      }
      case 61: {
        [self setPitch:[input readFloat]];
        break;
      }
      case 69: {
        [self setYaw:[input readFloat]];
        break;
      }
      case 77: {
        [self setRoll:[input readFloat]];
        break;
      }
    }
  }
}
- (BOOL) hasLocationX {
  return result.hasLocationX;
}
- (Float32) locationX {
  return result.locationX;
}
- (HandMotionEventBuilder*) setLocationX:(Float32) value {
  result.hasLocationX = YES;
  result.locationX = value;
  return self;
}
- (HandMotionEventBuilder*) clearLocationX {
  result.hasLocationX = NO;
  result.locationX = 0;
  return self;
}
- (BOOL) hasLocationY {
  return result.hasLocationY;
}
- (Float32) locationY {
  return result.locationY;
}
- (HandMotionEventBuilder*) setLocationY:(Float32) value {
  result.hasLocationY = YES;
  result.locationY = value;
  return self;
}
- (HandMotionEventBuilder*) clearLocationY {
  result.hasLocationY = NO;
  result.locationY = 0;
  return self;
}
- (BOOL) hasTrackareaWidth {
  return result.hasTrackareaWidth;
}
- (Float32) trackareaWidth {
  return result.trackareaWidth;
}
- (HandMotionEventBuilder*) setTrackareaWidth:(Float32) value {
  result.hasTrackareaWidth = YES;
  result.trackareaWidth = value;
  return self;
}
- (HandMotionEventBuilder*) clearTrackareaWidth {
  result.hasTrackareaWidth = NO;
  result.trackareaWidth = 0;
  return self;
}
- (BOOL) hasTrackareaHeight {
  return result.hasTrackareaHeight;
}
- (Float32) trackareaHeight {
  return result.trackareaHeight;
}
- (HandMotionEventBuilder*) setTrackareaHeight:(Float32) value {
  result.hasTrackareaHeight = YES;
  result.trackareaHeight = value;
  return self;
}
- (HandMotionEventBuilder*) clearTrackareaHeight {
  result.hasTrackareaHeight = NO;
  result.trackareaHeight = 0;
  return self;
}
- (BOOL) hasState {
  return result.hasState;
}
- (HandMotionEventState) state {
  return result.state;
}
- (HandMotionEventBuilder*) setState:(HandMotionEventState) value {
  result.hasState = YES;
  result.state = value;
  return self;
}
- (HandMotionEventBuilder*) clearState {
  result.hasState = NO;
  result.state = HandMotionEventStateOpen;
  return self;
}
- (BOOL) hasPhase {
  return result.hasPhase;
}
- (Phase) phase {
  return result.phase;
}
- (HandMotionEventBuilder*) setPhase:(Phase) value {
  result.hasPhase = YES;
  result.phase = value;
  return self;
}
- (HandMotionEventBuilder*) clearPhase {
  result.hasPhase = NO;
  result.phase = PhaseBegan;
  return self;
}
- (BOOL) hasPitch {
  return result.hasPitch;
}
- (Float32) pitch {
  return result.pitch;
}
- (HandMotionEventBuilder*) setPitch:(Float32) value {
  result.hasPitch = YES;
  result.pitch = value;
  return self;
}
- (HandMotionEventBuilder*) clearPitch {
  result.hasPitch = NO;
  result.pitch = 0;
  return self;
}
- (BOOL) hasYaw {
  return result.hasYaw;
}
- (Float32) yaw {
  return result.yaw;
}
- (HandMotionEventBuilder*) setYaw:(Float32) value {
  result.hasYaw = YES;
  result.yaw = value;
  return self;
}
- (HandMotionEventBuilder*) clearYaw {
  result.hasYaw = NO;
  result.yaw = 0;
  return self;
}
- (BOOL) hasRoll {
  return result.hasRoll;
}
- (Float32) roll {
  return result.roll;
}
- (HandMotionEventBuilder*) setRoll:(Float32) value {
  result.hasRoll = YES;
  result.roll = value;
  return self;
}
- (HandMotionEventBuilder*) clearRoll {
  result.hasRoll = NO;
  result.roll = 0;
  return self;
}
@end


// @@protoc_insertion_point(global_scope)
