// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "Proto.pb.h"
// @@protoc_insertion_point(imports)

@implementation ProtoRoot
static id<PBExtensionField> DeviceEvent_event = nil;
static id<PBExtensionField> TouchEvent_event = nil;
static id<PBExtensionField> MotionEvent_event = nil;
static id<PBExtensionField> KeypressEvent_event = nil;
static id<PBExtensionField> GestureEvent_event = nil;
static id<PBExtensionField> HandMotionEvent_event = nil;
static id<PBExtensionField> OAuthRequestEvent_event = nil;
static id<PBExtensionField> OAuthResponseEvent_event = nil;
static id<PBExtensionField> SetupRequestEvent_event = nil;
static id<PBExtensionField> SetupResponseEvent_event = nil;
static id<PBExtensionField> TextInputRequestEvent_event = nil;
static id<PBExtensionField> TextInputResponseEvent_event = nil;
static id<PBExtensionField> FunctionEvent_event = nil;
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [ProtoRoot class]) {
    DeviceEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:100
                                      defaultValue:[DeviceEvent defaultInstance]
                               messageOrGroupClass:[DeviceEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    TouchEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:101
                                      defaultValue:[TouchEvent defaultInstance]
                               messageOrGroupClass:[TouchEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    MotionEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:102
                                      defaultValue:[MotionEvent defaultInstance]
                               messageOrGroupClass:[MotionEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    KeypressEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:103
                                      defaultValue:[KeypressEvent defaultInstance]
                               messageOrGroupClass:[KeypressEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    GestureEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:104
                                      defaultValue:[GestureEvent defaultInstance]
                               messageOrGroupClass:[GestureEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    HandMotionEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:105
                                      defaultValue:[HandMotionEvent defaultInstance]
                               messageOrGroupClass:[HandMotionEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    OAuthRequestEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:106
                                      defaultValue:[OAuthRequestEvent defaultInstance]
                               messageOrGroupClass:[OAuthRequestEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    OAuthResponseEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:107
                                      defaultValue:[OAuthResponseEvent defaultInstance]
                               messageOrGroupClass:[OAuthResponseEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    SetupRequestEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:108
                                      defaultValue:[SetupRequestEvent defaultInstance]
                               messageOrGroupClass:[SetupRequestEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    SetupResponseEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:109
                                      defaultValue:[SetupResponseEvent defaultInstance]
                               messageOrGroupClass:[SetupResponseEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    TextInputRequestEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:110
                                      defaultValue:[TextInputRequestEvent defaultInstance]
                               messageOrGroupClass:[TextInputRequestEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    TextInputResponseEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:111
                                      defaultValue:[TextInputResponseEvent defaultInstance]
                               messageOrGroupClass:[TextInputResponseEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    FunctionEvent_event =
      [PBConcreteExtensionField extensionWithType:PBExtensionTypeMessage
                                     extendedClass:[Event class]
                                       fieldNumber:112
                                      defaultValue:[FunctionEvent defaultInstance]
                               messageOrGroupClass:[FunctionEvent class]
                                        isRepeated:NO
                                          isPacked:NO
                            isMessageSetWireFormat:NO];
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    extensionRegistry = registry;
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
  [registry addExtension:DeviceEvent_event];
  [registry addExtension:TouchEvent_event];
  [registry addExtension:MotionEvent_event];
  [registry addExtension:KeypressEvent_event];
  [registry addExtension:GestureEvent_event];
  [registry addExtension:HandMotionEvent_event];
  [registry addExtension:OAuthRequestEvent_event];
  [registry addExtension:OAuthResponseEvent_event];
  [registry addExtension:SetupRequestEvent_event];
  [registry addExtension:SetupResponseEvent_event];
  [registry addExtension:TextInputRequestEvent_event];
  [registry addExtension:TextInputResponseEvent_event];
  [registry addExtension:FunctionEvent_event];
}
@end

BOOL PhaseIsValidValue(Phase value) {
  switch (value) {
    case PhaseBegan:
    case PhaseMoved:
    case PhaseStationary:
    case PhaseEnded:
    case PhaseCancelled:
      return YES;
    default:
      return NO;
  }
}
BOOL SetupPhaseIsValidValue(SetupPhase value) {
  switch (value) {
    case SetupPhaseRequestCode:
    case SetupPhaseVerifyCode:
    case SetupPhaseRequestRename:
    case SetupPhaseRequestWifiScan:
    case SetupPhaseRequestWifiSelect:
    case SetupPhaseRequestWifiConnect:
      return YES;
    default:
      return NO;
  }
}
@interface Event ()
@property EventType type;
@property SInt64 timestamp;
@property SInt32 trackingAreaWidth;
@property SInt32 trackingAreaHeight;
@property (strong) NSString* target;
@property (strong) NSString* replyTo;
@end

@implementation Event

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasTimestamp {
  return !!hasTimestamp_;
}
- (void) setHasTimestamp:(BOOL) value_ {
  hasTimestamp_ = !!value_;
}
@synthesize timestamp;
- (BOOL) hasTrackingAreaWidth {
  return !!hasTrackingAreaWidth_;
}
- (void) setHasTrackingAreaWidth:(BOOL) value_ {
  hasTrackingAreaWidth_ = !!value_;
}
@synthesize trackingAreaWidth;
- (BOOL) hasTrackingAreaHeight {
  return !!hasTrackingAreaHeight_;
}
- (void) setHasTrackingAreaHeight:(BOOL) value_ {
  hasTrackingAreaHeight_ = !!value_;
}
@synthesize trackingAreaHeight;
- (BOOL) hasTarget {
  return !!hasTarget_;
}
- (void) setHasTarget:(BOOL) value_ {
  hasTarget_ = !!value_;
}
@synthesize target;
- (BOOL) hasReplyTo {
  return !!hasReplyTo_;
}
- (void) setHasReplyTo:(BOOL) value_ {
  hasReplyTo_ = !!value_;
}
@synthesize replyTo;
- (instancetype) init {
  if ((self = [super init])) {
    self.type = EventTypeDevice;
    self.timestamp = 0L;
    self.trackingAreaWidth = 0;
    self.trackingAreaHeight = 0;
    self.target = @"";
    self.replyTo = @"";
  }
  return self;
}
static Event* defaultEventInstance = nil;
+ (void) initialize {
  if (self == [Event class]) {
    defaultEventInstance = [[Event alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultEventInstance;
}
- (instancetype) defaultInstance {
  return defaultEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasType) {
    return NO;
  }
  if (!self.hasTimestamp) {
    return NO;
  }
  if (!self.hasTrackingAreaWidth) {
    return NO;
  }
  if (!self.hasTrackingAreaHeight) {
    return NO;
  }
  if (!self.extensionsAreInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  if (self.hasTimestamp) {
    [output writeInt64:2 value:self.timestamp];
  }
  if (self.hasTrackingAreaWidth) {
    [output writeInt32:3 value:self.trackingAreaWidth];
  }
  if (self.hasTrackingAreaHeight) {
    [output writeInt32:4 value:self.trackingAreaHeight];
  }
  if (self.hasTarget) {
    [output writeString:5 value:self.target];
  }
  if (self.hasReplyTo) {
    [output writeString:6 value:self.replyTo];
  }
  [self writeExtensionsToCodedOutputStream:output
                                      from:100
                                        to:536870912];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  if (self.hasTimestamp) {
    size_ += computeInt64Size(2, self.timestamp);
  }
  if (self.hasTrackingAreaWidth) {
    size_ += computeInt32Size(3, self.trackingAreaWidth);
  }
  if (self.hasTrackingAreaHeight) {
    size_ += computeInt32Size(4, self.trackingAreaHeight);
  }
  if (self.hasTarget) {
    size_ += computeStringSize(5, self.target);
  }
  if (self.hasReplyTo) {
    size_ += computeStringSize(6, self.replyTo);
  }
  size_ += [self extensionsSerializedSize];
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Event*) parseFromData:(NSData*) data {
  return (Event*)[[[Event builder] mergeFromData:data] build];
}
+ (Event*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Event*)[[[Event builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Event*) parseFromInputStream:(NSInputStream*) input {
  return (Event*)[[[Event builder] mergeFromInputStream:input] build];
}
+ (Event*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Event*)[[[Event builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Event*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Event*)[[[Event builder] mergeFromCodedInputStream:input] build];
}
+ (Event*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Event*)[[[Event builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (EventBuilder*) builder {
  return [[EventBuilder alloc] init];
}
+ (EventBuilder*) builderWithPrototype:(Event*) prototype {
  return [[Event builder] mergeFrom:prototype];
}
- (EventBuilder*) builder {
  return [Event builder];
}
- (EventBuilder*) toBuilder {
  return [Event builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
    [output appendFormat:@"%@%@: %@\n", indent, @"type", [NSNumber numberWithInteger:self.type]];
  }
  if (self.hasTimestamp) {
    [output appendFormat:@"%@%@: %@\n", indent, @"timestamp", [NSNumber numberWithLongLong:self.timestamp]];
  }
  if (self.hasTrackingAreaWidth) {
    [output appendFormat:@"%@%@: %@\n", indent, @"trackingAreaWidth", [NSNumber numberWithInteger:self.trackingAreaWidth]];
  }
  if (self.hasTrackingAreaHeight) {
    [output appendFormat:@"%@%@: %@\n", indent, @"trackingAreaHeight", [NSNumber numberWithInteger:self.trackingAreaHeight]];
  }
  if (self.hasTarget) {
    [output appendFormat:@"%@%@: %@\n", indent, @"target", self.target];
  }
  if (self.hasReplyTo) {
    [output appendFormat:@"%@%@: %@\n", indent, @"replyTo", self.replyTo];
  }
  [self writeExtensionDescriptionToMutableString:(NSMutableString*)output
                                            from:100
                                              to:536870912
                                      withIndent:indent];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Event class]]) {
    return NO;
  }
  Event *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasTimestamp == otherMessage.hasTimestamp &&
      (!self.hasTimestamp || self.timestamp == otherMessage.timestamp) &&
      self.hasTrackingAreaWidth == otherMessage.hasTrackingAreaWidth &&
      (!self.hasTrackingAreaWidth || self.trackingAreaWidth == otherMessage.trackingAreaWidth) &&
      self.hasTrackingAreaHeight == otherMessage.hasTrackingAreaHeight &&
      (!self.hasTrackingAreaHeight || self.trackingAreaHeight == otherMessage.trackingAreaHeight) &&
      self.hasTarget == otherMessage.hasTarget &&
      (!self.hasTarget || [self.target isEqual:otherMessage.target]) &&
      self.hasReplyTo == otherMessage.hasReplyTo &&
      (!self.hasReplyTo || [self.replyTo isEqual:otherMessage.replyTo]) &&
      [self isEqualExtensionsInOther:otherMessage from:100 to:536870912] &&

      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasTimestamp) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.timestamp] hash];
  }
  if (self.hasTrackingAreaWidth) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.trackingAreaWidth] hash];
  }
  if (self.hasTrackingAreaHeight) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.trackingAreaHeight] hash];
  }
  if (self.hasTarget) {
    hashCode = hashCode * 31 + [self.target hash];
  }
  if (self.hasReplyTo) {
    hashCode = hashCode * 31 + [self.replyTo hash];
  }
  hashCode = hashCode * 31 + [self hashExtensionsFrom:100 to:536870912];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL EventTypeIsValidValue(EventType value) {
  switch (value) {
    case EventTypeDevice:
    case EventTypeTouch:
    case EventTypeMotion:
    case EventTypeKeypress:
    case EventTypeGesture:
    case EventTypeHandMotion:
    case EventTypeHandGesture:
    case EventTypeOauthRequest:
    case EventTypeOauthResponse:
    case EventTypeSetupRequest:
    case EventTypeSetupResponse:
    case EventTypeTextInputRequest:
    case EventTypeTextInputResponse:
    case EventTypeFunctionEvent:
      return YES;
    default:
      return NO;
  }
}
@interface EventBuilder()
@property (strong) Event* resultEvent;
@end

@implementation EventBuilder
@synthesize resultEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultEvent = [[Event alloc] init];
  }
  return self;
}
- (PBExtendableMessage*) internalGetResult {
  return resultEvent;
}
- (EventBuilder*) clear {
  self.resultEvent = [[Event alloc] init];
  return self;
}
- (EventBuilder*) clone {
  return [Event builderWithPrototype:resultEvent];
}
- (Event*) defaultInstance {
  return [Event defaultInstance];
}
- (Event*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Event*) buildPartial {
  Event* returnMe = resultEvent;
  self.resultEvent = nil;
  return returnMe;
}
- (EventBuilder*) mergeFrom:(Event*) other {
  if (other == [Event defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasTimestamp) {
    [self setTimestamp:other.timestamp];
  }
  if (other.hasTrackingAreaWidth) {
    [self setTrackingAreaWidth:other.trackingAreaWidth];
  }
  if (other.hasTrackingAreaHeight) {
    [self setTrackingAreaHeight:other.trackingAreaHeight];
  }
  if (other.hasTarget) {
    [self setTarget:other.target];
  }
  if (other.hasReplyTo) {
    [self setReplyTo:other.replyTo];
  }
  [self mergeExtensionFields:other];
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (EventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (EventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        EventType value = (EventType)[input readEnum];
        if (EventTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 16: {
        [self setTimestamp:[input readInt64]];
        break;
      }
      case 24: {
        [self setTrackingAreaWidth:[input readInt32]];
        break;
      }
      case 32: {
        [self setTrackingAreaHeight:[input readInt32]];
        break;
      }
      case 42: {
        [self setTarget:[input readString]];
        break;
      }
      case 50: {
        [self setReplyTo:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return resultEvent.hasType;
}
- (EventType) type {
  return resultEvent.type;
}
- (EventBuilder*) setType:(EventType) value {
  resultEvent.hasType = YES;
  resultEvent.type = value;
  return self;
}
- (EventBuilder*) clearType {
  resultEvent.hasType = NO;
  resultEvent.type = EventTypeDevice;
  return self;
}
- (BOOL) hasTimestamp {
  return resultEvent.hasTimestamp;
}
- (SInt64) timestamp {
  return resultEvent.timestamp;
}
- (EventBuilder*) setTimestamp:(SInt64) value {
  resultEvent.hasTimestamp = YES;
  resultEvent.timestamp = value;
  return self;
}
- (EventBuilder*) clearTimestamp {
  resultEvent.hasTimestamp = NO;
  resultEvent.timestamp = 0L;
  return self;
}
- (BOOL) hasTrackingAreaWidth {
  return resultEvent.hasTrackingAreaWidth;
}
- (SInt32) trackingAreaWidth {
  return resultEvent.trackingAreaWidth;
}
- (EventBuilder*) setTrackingAreaWidth:(SInt32) value {
  resultEvent.hasTrackingAreaWidth = YES;
  resultEvent.trackingAreaWidth = value;
  return self;
}
- (EventBuilder*) clearTrackingAreaWidth {
  resultEvent.hasTrackingAreaWidth = NO;
  resultEvent.trackingAreaWidth = 0;
  return self;
}
- (BOOL) hasTrackingAreaHeight {
  return resultEvent.hasTrackingAreaHeight;
}
- (SInt32) trackingAreaHeight {
  return resultEvent.trackingAreaHeight;
}
- (EventBuilder*) setTrackingAreaHeight:(SInt32) value {
  resultEvent.hasTrackingAreaHeight = YES;
  resultEvent.trackingAreaHeight = value;
  return self;
}
- (EventBuilder*) clearTrackingAreaHeight {
  resultEvent.hasTrackingAreaHeight = NO;
  resultEvent.trackingAreaHeight = 0;
  return self;
}
- (BOOL) hasTarget {
  return resultEvent.hasTarget;
}
- (NSString*) target {
  return resultEvent.target;
}
- (EventBuilder*) setTarget:(NSString*) value {
  resultEvent.hasTarget = YES;
  resultEvent.target = value;
  return self;
}
- (EventBuilder*) clearTarget {
  resultEvent.hasTarget = NO;
  resultEvent.target = @"";
  return self;
}
- (BOOL) hasReplyTo {
  return resultEvent.hasReplyTo;
}
- (NSString*) replyTo {
  return resultEvent.replyTo;
}
- (EventBuilder*) setReplyTo:(NSString*) value {
  resultEvent.hasReplyTo = YES;
  resultEvent.replyTo = value;
  return self;
}
- (EventBuilder*) clearReplyTo {
  resultEvent.hasReplyTo = NO;
  resultEvent.replyTo = @"";
  return self;
}
@end

@interface Device ()
@property (strong) NSString* name;
@property DeviceVendor vendor;
@property SInt32 version;
@property (strong) NSString* productId;
@property BOOL hasKeyboard;
@end

@implementation Device

- (BOOL) hasName {
  return !!hasName_;
}
- (void) setHasName:(BOOL) value_ {
  hasName_ = !!value_;
}
@synthesize name;
- (BOOL) hasVendor {
  return !!hasVendor_;
}
- (void) setHasVendor:(BOOL) value_ {
  hasVendor_ = !!value_;
}
@synthesize vendor;
- (BOOL) hasVersion {
  return !!hasVersion_;
}
- (void) setHasVersion:(BOOL) value_ {
  hasVersion_ = !!value_;
}
@synthesize version;
- (BOOL) hasProductId {
  return !!hasProductId_;
}
- (void) setHasProductId:(BOOL) value_ {
  hasProductId_ = !!value_;
}
@synthesize productId;
- (BOOL) hasHasKeyboard {
  return !!hasHasKeyboard_;
}
- (void) setHasHasKeyboard:(BOOL) value_ {
  hasHasKeyboard_ = !!value_;
}
- (BOOL) hasKeyboard {
  return !!hasKeyboard_;
}
- (void) setHasKeyboard:(BOOL) value_ {
  hasKeyboard_ = !!value_;
}
- (instancetype) init {
  if ((self = [super init])) {
    self.name = @"";
    self.vendor = DeviceVendorIos;
    self.version = 0;
    self.productId = @"";
    self.hasKeyboard = NO;
  }
  return self;
}
static Device* defaultDeviceInstance = nil;
+ (void) initialize {
  if (self == [Device class]) {
    defaultDeviceInstance = [[Device alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultDeviceInstance;
}
- (instancetype) defaultInstance {
  return defaultDeviceInstance;
}
- (BOOL) isInitialized {
  if (!self.hasName) {
    return NO;
  }
  if (!self.hasVendor) {
    return NO;
  }
  if (!self.hasProductId) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasName) {
    [output writeString:1 value:self.name];
  }
  if (self.hasVendor) {
    [output writeEnum:2 value:self.vendor];
  }
  if (self.hasVersion) {
    [output writeInt32:3 value:self.version];
  }
  if (self.hasProductId) {
    [output writeString:4 value:self.productId];
  }
  if (self.hasHasKeyboard) {
    [output writeBool:5 value:self.hasKeyboard];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasName) {
    size_ += computeStringSize(1, self.name);
  }
  if (self.hasVendor) {
    size_ += computeEnumSize(2, self.vendor);
  }
  if (self.hasVersion) {
    size_ += computeInt32Size(3, self.version);
  }
  if (self.hasProductId) {
    size_ += computeStringSize(4, self.productId);
  }
  if (self.hasHasKeyboard) {
    size_ += computeBoolSize(5, self.hasKeyboard);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Device*) parseFromData:(NSData*) data {
  return (Device*)[[[Device builder] mergeFromData:data] build];
}
+ (Device*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Device*)[[[Device builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Device*) parseFromInputStream:(NSInputStream*) input {
  return (Device*)[[[Device builder] mergeFromInputStream:input] build];
}
+ (Device*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Device*)[[[Device builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Device*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Device*)[[[Device builder] mergeFromCodedInputStream:input] build];
}
+ (Device*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Device*)[[[Device builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceBuilder*) builder {
  return [[DeviceBuilder alloc] init];
}
+ (DeviceBuilder*) builderWithPrototype:(Device*) prototype {
  return [[Device builder] mergeFrom:prototype];
}
- (DeviceBuilder*) builder {
  return [Device builder];
}
- (DeviceBuilder*) toBuilder {
  return [Device builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasName) {
    [output appendFormat:@"%@%@: %@\n", indent, @"name", self.name];
  }
  if (self.hasVendor) {
    [output appendFormat:@"%@%@: %@\n", indent, @"vendor", [NSNumber numberWithInteger:self.vendor]];
  }
  if (self.hasVersion) {
    [output appendFormat:@"%@%@: %@\n", indent, @"version", [NSNumber numberWithInteger:self.version]];
  }
  if (self.hasProductId) {
    [output appendFormat:@"%@%@: %@\n", indent, @"productId", self.productId];
  }
  if (self.hasHasKeyboard) {
    [output appendFormat:@"%@%@: %@\n", indent, @"hasKeyboard", [NSNumber numberWithBool:self.hasKeyboard]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Device class]]) {
    return NO;
  }
  Device *otherMessage = other;
  return
      self.hasName == otherMessage.hasName &&
      (!self.hasName || [self.name isEqual:otherMessage.name]) &&
      self.hasVendor == otherMessage.hasVendor &&
      (!self.hasVendor || self.vendor == otherMessage.vendor) &&
      self.hasVersion == otherMessage.hasVersion &&
      (!self.hasVersion || self.version == otherMessage.version) &&
      self.hasProductId == otherMessage.hasProductId &&
      (!self.hasProductId || [self.productId isEqual:otherMessage.productId]) &&
      self.hasHasKeyboard == otherMessage.hasHasKeyboard &&
      (!self.hasHasKeyboard || self.hasKeyboard == otherMessage.hasKeyboard) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasName) {
    hashCode = hashCode * 31 + [self.name hash];
  }
  if (self.hasVendor) {
    hashCode = hashCode * 31 + self.vendor;
  }
  if (self.hasVersion) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.version] hash];
  }
  if (self.hasProductId) {
    hashCode = hashCode * 31 + [self.productId hash];
  }
  if (self.hasHasKeyboard) {
    hashCode = hashCode * 31 + [[NSNumber numberWithBool:self.hasKeyboard] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL DeviceVendorIsValidValue(DeviceVendor value) {
  switch (value) {
    case DeviceVendorIos:
    case DeviceVendorAndroid:
    case DeviceVendorLeapmotion:
    case DeviceVendorKinect:
    case DeviceVendorWindows:
    case DeviceVendorOther:
      return YES;
    default:
      return NO;
  }
}
@interface DeviceBuilder()
@property (strong) Device* resultDevice;
@end

@implementation DeviceBuilder
@synthesize resultDevice;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultDevice = [[Device alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultDevice;
}
- (DeviceBuilder*) clear {
  self.resultDevice = [[Device alloc] init];
  return self;
}
- (DeviceBuilder*) clone {
  return [Device builderWithPrototype:resultDevice];
}
- (Device*) defaultInstance {
  return [Device defaultInstance];
}
- (Device*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Device*) buildPartial {
  Device* returnMe = resultDevice;
  self.resultDevice = nil;
  return returnMe;
}
- (DeviceBuilder*) mergeFrom:(Device*) other {
  if (other == [Device defaultInstance]) {
    return self;
  }
  if (other.hasName) {
    [self setName:other.name];
  }
  if (other.hasVendor) {
    [self setVendor:other.vendor];
  }
  if (other.hasVersion) {
    [self setVersion:other.version];
  }
  if (other.hasProductId) {
    [self setProductId:other.productId];
  }
  if (other.hasHasKeyboard) {
    [self setHasKeyboard:other.hasKeyboard];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (DeviceBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (DeviceBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setName:[input readString]];
        break;
      }
      case 16: {
        DeviceVendor value = (DeviceVendor)[input readEnum];
        if (DeviceVendorIsValidValue(value)) {
          [self setVendor:value];
        } else {
          [unknownFields mergeVarintField:2 value:value];
        }
        break;
      }
      case 24: {
        [self setVersion:[input readInt32]];
        break;
      }
      case 34: {
        [self setProductId:[input readString]];
        break;
      }
      case 40: {
        [self setHasKeyboard:[input readBool]];
        break;
      }
    }
  }
}
- (BOOL) hasName {
  return resultDevice.hasName;
}
- (NSString*) name {
  return resultDevice.name;
}
- (DeviceBuilder*) setName:(NSString*) value {
  resultDevice.hasName = YES;
  resultDevice.name = value;
  return self;
}
- (DeviceBuilder*) clearName {
  resultDevice.hasName = NO;
  resultDevice.name = @"";
  return self;
}
- (BOOL) hasVendor {
  return resultDevice.hasVendor;
}
- (DeviceVendor) vendor {
  return resultDevice.vendor;
}
- (DeviceBuilder*) setVendor:(DeviceVendor) value {
  resultDevice.hasVendor = YES;
  resultDevice.vendor = value;
  return self;
}
- (DeviceBuilder*) clearVendor {
  resultDevice.hasVendor = NO;
  resultDevice.vendor = DeviceVendorIos;
  return self;
}
- (BOOL) hasVersion {
  return resultDevice.hasVersion;
}
- (SInt32) version {
  return resultDevice.version;
}
- (DeviceBuilder*) setVersion:(SInt32) value {
  resultDevice.hasVersion = YES;
  resultDevice.version = value;
  return self;
}
- (DeviceBuilder*) clearVersion {
  resultDevice.hasVersion = NO;
  resultDevice.version = 0;
  return self;
}
- (BOOL) hasProductId {
  return resultDevice.hasProductId;
}
- (NSString*) productId {
  return resultDevice.productId;
}
- (DeviceBuilder*) setProductId:(NSString*) value {
  resultDevice.hasProductId = YES;
  resultDevice.productId = value;
  return self;
}
- (DeviceBuilder*) clearProductId {
  resultDevice.hasProductId = NO;
  resultDevice.productId = @"";
  return self;
}
- (BOOL) hasHasKeyboard {
  return resultDevice.hasHasKeyboard;
}
- (BOOL) hasKeyboard {
  return resultDevice.hasKeyboard;
}
- (DeviceBuilder*) setHasKeyboard:(BOOL) value {
  resultDevice.hasHasKeyboard = YES;
  resultDevice.hasKeyboard = value;
  return self;
}
- (DeviceBuilder*) clearHasKeyboard {
  resultDevice.hasHasKeyboard = NO;
  resultDevice.hasKeyboard = NO;
  return self;
}
@end

@interface DeviceEvent ()
@property DeviceEventType type;
@property (strong) Device* device;
@end

@implementation DeviceEvent

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasDevice {
  return !!hasDevice_;
}
- (void) setHasDevice:(BOOL) value_ {
  hasDevice_ = !!value_;
}
@synthesize device;
- (instancetype) init {
  if ((self = [super init])) {
    self.type = DeviceEventTypeRegister;
    self.device = [Device defaultInstance];
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return DeviceEvent_event;
}
static DeviceEvent* defaultDeviceEventInstance = nil;
+ (void) initialize {
  if (self == [DeviceEvent class]) {
    defaultDeviceEventInstance = [[DeviceEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultDeviceEventInstance;
}
- (instancetype) defaultInstance {
  return defaultDeviceEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasType) {
    return NO;
  }
  if (!self.hasDevice) {
    return NO;
  }
  if (!self.device.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  if (self.hasDevice) {
    [output writeMessage:2 value:self.device];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  if (self.hasDevice) {
    size_ += computeMessageSize(2, self.device);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (DeviceEvent*) parseFromData:(NSData*) data {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromData:data] build];
}
+ (DeviceEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (DeviceEvent*) parseFromInputStream:(NSInputStream*) input {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromInputStream:input] build];
}
+ (DeviceEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromCodedInputStream:input] build];
}
+ (DeviceEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceEvent*)[[[DeviceEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceEventBuilder*) builder {
  return [[DeviceEventBuilder alloc] init];
}
+ (DeviceEventBuilder*) builderWithPrototype:(DeviceEvent*) prototype {
  return [[DeviceEvent builder] mergeFrom:prototype];
}
- (DeviceEventBuilder*) builder {
  return [DeviceEvent builder];
}
- (DeviceEventBuilder*) toBuilder {
  return [DeviceEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
    [output appendFormat:@"%@%@: %@\n", indent, @"type", [NSNumber numberWithInteger:self.type]];
  }
  if (self.hasDevice) {
    [output appendFormat:@"%@%@ {\n", indent, @"device"];
    [self.device writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[DeviceEvent class]]) {
    return NO;
  }
  DeviceEvent *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasDevice == otherMessage.hasDevice &&
      (!self.hasDevice || [self.device isEqual:otherMessage.device]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasDevice) {
    hashCode = hashCode * 31 + [self.device hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL DeviceEventTypeIsValidValue(DeviceEventType value) {
  switch (value) {
    case DeviceEventTypeRegister:
    case DeviceEventTypeUnregister:
      return YES;
    default:
      return NO;
  }
}
@interface DeviceEventBuilder()
@property (strong) DeviceEvent* resultDeviceEvent;
@end

@implementation DeviceEventBuilder
@synthesize resultDeviceEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultDeviceEvent = [[DeviceEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultDeviceEvent;
}
- (DeviceEventBuilder*) clear {
  self.resultDeviceEvent = [[DeviceEvent alloc] init];
  return self;
}
- (DeviceEventBuilder*) clone {
  return [DeviceEvent builderWithPrototype:resultDeviceEvent];
}
- (DeviceEvent*) defaultInstance {
  return [DeviceEvent defaultInstance];
}
- (DeviceEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (DeviceEvent*) buildPartial {
  DeviceEvent* returnMe = resultDeviceEvent;
  self.resultDeviceEvent = nil;
  return returnMe;
}
- (DeviceEventBuilder*) mergeFrom:(DeviceEvent*) other {
  if (other == [DeviceEvent defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasDevice) {
    [self mergeDevice:other.device];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (DeviceEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (DeviceEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        DeviceEventType value = (DeviceEventType)[input readEnum];
        if (DeviceEventTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 18: {
        DeviceBuilder* subBuilder = [Device builder];
        if (self.hasDevice) {
          [subBuilder mergeFrom:self.device];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setDevice:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return resultDeviceEvent.hasType;
}
- (DeviceEventType) type {
  return resultDeviceEvent.type;
}
- (DeviceEventBuilder*) setType:(DeviceEventType) value {
  resultDeviceEvent.hasType = YES;
  resultDeviceEvent.type = value;
  return self;
}
- (DeviceEventBuilder*) clearType {
  resultDeviceEvent.hasType = NO;
  resultDeviceEvent.type = DeviceEventTypeRegister;
  return self;
}
- (BOOL) hasDevice {
  return resultDeviceEvent.hasDevice;
}
- (Device*) device {
  return resultDeviceEvent.device;
}
- (DeviceEventBuilder*) setDevice:(Device*) value {
  resultDeviceEvent.hasDevice = YES;
  resultDeviceEvent.device = value;
  return self;
}
- (DeviceEventBuilder*) setDeviceBuilder:(DeviceBuilder*) builderForValue {
  return [self setDevice:[builderForValue build]];
}
- (DeviceEventBuilder*) mergeDevice:(Device*) value {
  if (resultDeviceEvent.hasDevice &&
      resultDeviceEvent.device != [Device defaultInstance]) {
    resultDeviceEvent.device =
      [[[Device builderWithPrototype:resultDeviceEvent.device] mergeFrom:value] buildPartial];
  } else {
    resultDeviceEvent.device = value;
  }
  resultDeviceEvent.hasDevice = YES;
  return self;
}
- (DeviceEventBuilder*) clearDevice {
  resultDeviceEvent.hasDevice = NO;
  resultDeviceEvent.device = [Device defaultInstance];
  return self;
}
@end

@interface TouchEvent ()
@property Float32 locationX;
@property Float32 locationY;
@property Phase phase;
@end

@implementation TouchEvent

- (BOOL) hasLocationX {
  return !!hasLocationX_;
}
- (void) setHasLocationX:(BOOL) value_ {
  hasLocationX_ = !!value_;
}
@synthesize locationX;
- (BOOL) hasLocationY {
  return !!hasLocationY_;
}
- (void) setHasLocationY:(BOOL) value_ {
  hasLocationY_ = !!value_;
}
@synthesize locationY;
- (BOOL) hasPhase {
  return !!hasPhase_;
}
- (void) setHasPhase:(BOOL) value_ {
  hasPhase_ = !!value_;
}
@synthesize phase;
- (instancetype) init {
  if ((self = [super init])) {
    self.locationX = 0;
    self.locationY = 0;
    self.phase = PhaseBegan;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return TouchEvent_event;
}
static TouchEvent* defaultTouchEventInstance = nil;
+ (void) initialize {
  if (self == [TouchEvent class]) {
    defaultTouchEventInstance = [[TouchEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultTouchEventInstance;
}
- (instancetype) defaultInstance {
  return defaultTouchEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasLocationX) {
    return NO;
  }
  if (!self.hasLocationY) {
    return NO;
  }
  if (!self.hasPhase) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasLocationX) {
    [output writeFloat:1 value:self.locationX];
  }
  if (self.hasLocationY) {
    [output writeFloat:2 value:self.locationY];
  }
  if (self.hasPhase) {
    [output writeEnum:3 value:self.phase];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasLocationX) {
    size_ += computeFloatSize(1, self.locationX);
  }
  if (self.hasLocationY) {
    size_ += computeFloatSize(2, self.locationY);
  }
  if (self.hasPhase) {
    size_ += computeEnumSize(3, self.phase);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (TouchEvent*) parseFromData:(NSData*) data {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromData:data] build];
}
+ (TouchEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TouchEvent*) parseFromInputStream:(NSInputStream*) input {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromInputStream:input] build];
}
+ (TouchEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TouchEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromCodedInputStream:input] build];
}
+ (TouchEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TouchEvent*)[[[TouchEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TouchEventBuilder*) builder {
  return [[TouchEventBuilder alloc] init];
}
+ (TouchEventBuilder*) builderWithPrototype:(TouchEvent*) prototype {
  return [[TouchEvent builder] mergeFrom:prototype];
}
- (TouchEventBuilder*) builder {
  return [TouchEvent builder];
}
- (TouchEventBuilder*) toBuilder {
  return [TouchEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasLocationX) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationX", [NSNumber numberWithFloat:self.locationX]];
  }
  if (self.hasLocationY) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationY", [NSNumber numberWithFloat:self.locationY]];
  }
  if (self.hasPhase) {
    [output appendFormat:@"%@%@: %@\n", indent, @"phase", [NSNumber numberWithInteger:self.phase]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[TouchEvent class]]) {
    return NO;
  }
  TouchEvent *otherMessage = other;
  return
      self.hasLocationX == otherMessage.hasLocationX &&
      (!self.hasLocationX || self.locationX == otherMessage.locationX) &&
      self.hasLocationY == otherMessage.hasLocationY &&
      (!self.hasLocationY || self.locationY == otherMessage.locationY) &&
      self.hasPhase == otherMessage.hasPhase &&
      (!self.hasPhase || self.phase == otherMessage.phase) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasLocationX) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationX] hash];
  }
  if (self.hasLocationY) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationY] hash];
  }
  if (self.hasPhase) {
    hashCode = hashCode * 31 + self.phase;
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface TouchEventBuilder()
@property (strong) TouchEvent* resultTouchEvent;
@end

@implementation TouchEventBuilder
@synthesize resultTouchEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultTouchEvent = [[TouchEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultTouchEvent;
}
- (TouchEventBuilder*) clear {
  self.resultTouchEvent = [[TouchEvent alloc] init];
  return self;
}
- (TouchEventBuilder*) clone {
  return [TouchEvent builderWithPrototype:resultTouchEvent];
}
- (TouchEvent*) defaultInstance {
  return [TouchEvent defaultInstance];
}
- (TouchEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TouchEvent*) buildPartial {
  TouchEvent* returnMe = resultTouchEvent;
  self.resultTouchEvent = nil;
  return returnMe;
}
- (TouchEventBuilder*) mergeFrom:(TouchEvent*) other {
  if (other == [TouchEvent defaultInstance]) {
    return self;
  }
  if (other.hasLocationX) {
    [self setLocationX:other.locationX];
  }
  if (other.hasLocationY) {
    [self setLocationY:other.locationY];
  }
  if (other.hasPhase) {
    [self setPhase:other.phase];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TouchEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TouchEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 13: {
        [self setLocationX:[input readFloat]];
        break;
      }
      case 21: {
        [self setLocationY:[input readFloat]];
        break;
      }
      case 24: {
        Phase value = (Phase)[input readEnum];
        if (PhaseIsValidValue(value)) {
          [self setPhase:value];
        } else {
          [unknownFields mergeVarintField:3 value:value];
        }
        break;
      }
    }
  }
}
- (BOOL) hasLocationX {
  return resultTouchEvent.hasLocationX;
}
- (Float32) locationX {
  return resultTouchEvent.locationX;
}
- (TouchEventBuilder*) setLocationX:(Float32) value {
  resultTouchEvent.hasLocationX = YES;
  resultTouchEvent.locationX = value;
  return self;
}
- (TouchEventBuilder*) clearLocationX {
  resultTouchEvent.hasLocationX = NO;
  resultTouchEvent.locationX = 0;
  return self;
}
- (BOOL) hasLocationY {
  return resultTouchEvent.hasLocationY;
}
- (Float32) locationY {
  return resultTouchEvent.locationY;
}
- (TouchEventBuilder*) setLocationY:(Float32) value {
  resultTouchEvent.hasLocationY = YES;
  resultTouchEvent.locationY = value;
  return self;
}
- (TouchEventBuilder*) clearLocationY {
  resultTouchEvent.hasLocationY = NO;
  resultTouchEvent.locationY = 0;
  return self;
}
- (BOOL) hasPhase {
  return resultTouchEvent.hasPhase;
}
- (Phase) phase {
  return resultTouchEvent.phase;
}
- (TouchEventBuilder*) setPhase:(Phase) value {
  resultTouchEvent.hasPhase = YES;
  resultTouchEvent.phase = value;
  return self;
}
- (TouchEventBuilder*) clearPhase {
  resultTouchEvent.hasPhase = NO;
  resultTouchEvent.phase = PhaseBegan;
  return self;
}
@end

@interface MotionEvent ()
@property MotionEventType type;
@end

@implementation MotionEvent

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (instancetype) init {
  if ((self = [super init])) {
    self.type = MotionEventTypeShake;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return MotionEvent_event;
}
static MotionEvent* defaultMotionEventInstance = nil;
+ (void) initialize {
  if (self == [MotionEvent class]) {
    defaultMotionEventInstance = [[MotionEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultMotionEventInstance;
}
- (instancetype) defaultInstance {
  return defaultMotionEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasType) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (MotionEvent*) parseFromData:(NSData*) data {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromData:data] build];
}
+ (MotionEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (MotionEvent*) parseFromInputStream:(NSInputStream*) input {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromInputStream:input] build];
}
+ (MotionEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MotionEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromCodedInputStream:input] build];
}
+ (MotionEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MotionEvent*)[[[MotionEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MotionEventBuilder*) builder {
  return [[MotionEventBuilder alloc] init];
}
+ (MotionEventBuilder*) builderWithPrototype:(MotionEvent*) prototype {
  return [[MotionEvent builder] mergeFrom:prototype];
}
- (MotionEventBuilder*) builder {
  return [MotionEvent builder];
}
- (MotionEventBuilder*) toBuilder {
  return [MotionEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
    [output appendFormat:@"%@%@: %@\n", indent, @"type", [NSNumber numberWithInteger:self.type]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[MotionEvent class]]) {
    return NO;
  }
  MotionEvent *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL MotionEventTypeIsValidValue(MotionEventType value) {
  switch (value) {
    case MotionEventTypeShake:
      return YES;
    default:
      return NO;
  }
}
@interface MotionEventBuilder()
@property (strong) MotionEvent* resultMotionEvent;
@end

@implementation MotionEventBuilder
@synthesize resultMotionEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultMotionEvent = [[MotionEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultMotionEvent;
}
- (MotionEventBuilder*) clear {
  self.resultMotionEvent = [[MotionEvent alloc] init];
  return self;
}
- (MotionEventBuilder*) clone {
  return [MotionEvent builderWithPrototype:resultMotionEvent];
}
- (MotionEvent*) defaultInstance {
  return [MotionEvent defaultInstance];
}
- (MotionEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (MotionEvent*) buildPartial {
  MotionEvent* returnMe = resultMotionEvent;
  self.resultMotionEvent = nil;
  return returnMe;
}
- (MotionEventBuilder*) mergeFrom:(MotionEvent*) other {
  if (other == [MotionEvent defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (MotionEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (MotionEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        MotionEventType value = (MotionEventType)[input readEnum];
        if (MotionEventTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return resultMotionEvent.hasType;
}
- (MotionEventType) type {
  return resultMotionEvent.type;
}
- (MotionEventBuilder*) setType:(MotionEventType) value {
  resultMotionEvent.hasType = YES;
  resultMotionEvent.type = value;
  return self;
}
- (MotionEventBuilder*) clearType {
  resultMotionEvent.hasType = NO;
  resultMotionEvent.type = MotionEventTypeShake;
  return self;
}
@end

@interface KeypressEvent ()
@property KeypressEventState state;
@property SInt32 keycode;
@end

@implementation KeypressEvent

- (BOOL) hasState {
  return !!hasState_;
}
- (void) setHasState:(BOOL) value_ {
  hasState_ = !!value_;
}
@synthesize state;
- (BOOL) hasKeycode {
  return !!hasKeycode_;
}
- (void) setHasKeycode:(BOOL) value_ {
  hasKeycode_ = !!value_;
}
@synthesize keycode;
- (instancetype) init {
  if ((self = [super init])) {
    self.state = KeypressEventStateDown;
    self.keycode = 0;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return KeypressEvent_event;
}
static KeypressEvent* defaultKeypressEventInstance = nil;
+ (void) initialize {
  if (self == [KeypressEvent class]) {
    defaultKeypressEventInstance = [[KeypressEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultKeypressEventInstance;
}
- (instancetype) defaultInstance {
  return defaultKeypressEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasState) {
    return NO;
  }
  if (!self.hasKeycode) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasState) {
    [output writeEnum:1 value:self.state];
  }
  if (self.hasKeycode) {
    [output writeInt32:2 value:self.keycode];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasState) {
    size_ += computeEnumSize(1, self.state);
  }
  if (self.hasKeycode) {
    size_ += computeInt32Size(2, self.keycode);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (KeypressEvent*) parseFromData:(NSData*) data {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromData:data] build];
}
+ (KeypressEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (KeypressEvent*) parseFromInputStream:(NSInputStream*) input {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromInputStream:input] build];
}
+ (KeypressEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (KeypressEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromCodedInputStream:input] build];
}
+ (KeypressEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeypressEvent*)[[[KeypressEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (KeypressEventBuilder*) builder {
  return [[KeypressEventBuilder alloc] init];
}
+ (KeypressEventBuilder*) builderWithPrototype:(KeypressEvent*) prototype {
  return [[KeypressEvent builder] mergeFrom:prototype];
}
- (KeypressEventBuilder*) builder {
  return [KeypressEvent builder];
}
- (KeypressEventBuilder*) toBuilder {
  return [KeypressEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasState) {
    [output appendFormat:@"%@%@: %@\n", indent, @"state", [NSNumber numberWithInteger:self.state]];
  }
  if (self.hasKeycode) {
    [output appendFormat:@"%@%@: %@\n", indent, @"keycode", [NSNumber numberWithInteger:self.keycode]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[KeypressEvent class]]) {
    return NO;
  }
  KeypressEvent *otherMessage = other;
  return
      self.hasState == otherMessage.hasState &&
      (!self.hasState || self.state == otherMessage.state) &&
      self.hasKeycode == otherMessage.hasKeycode &&
      (!self.hasKeycode || self.keycode == otherMessage.keycode) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasState) {
    hashCode = hashCode * 31 + self.state;
  }
  if (self.hasKeycode) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.keycode] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL KeypressEventStateIsValidValue(KeypressEventState value) {
  switch (value) {
    case KeypressEventStateDown:
    case KeypressEventStateUp:
      return YES;
    default:
      return NO;
  }
}
@interface KeypressEventBuilder()
@property (strong) KeypressEvent* resultKeypressEvent;
@end

@implementation KeypressEventBuilder
@synthesize resultKeypressEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultKeypressEvent = [[KeypressEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultKeypressEvent;
}
- (KeypressEventBuilder*) clear {
  self.resultKeypressEvent = [[KeypressEvent alloc] init];
  return self;
}
- (KeypressEventBuilder*) clone {
  return [KeypressEvent builderWithPrototype:resultKeypressEvent];
}
- (KeypressEvent*) defaultInstance {
  return [KeypressEvent defaultInstance];
}
- (KeypressEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (KeypressEvent*) buildPartial {
  KeypressEvent* returnMe = resultKeypressEvent;
  self.resultKeypressEvent = nil;
  return returnMe;
}
- (KeypressEventBuilder*) mergeFrom:(KeypressEvent*) other {
  if (other == [KeypressEvent defaultInstance]) {
    return self;
  }
  if (other.hasState) {
    [self setState:other.state];
  }
  if (other.hasKeycode) {
    [self setKeycode:other.keycode];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (KeypressEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (KeypressEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        KeypressEventState value = (KeypressEventState)[input readEnum];
        if (KeypressEventStateIsValidValue(value)) {
          [self setState:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 16: {
        [self setKeycode:[input readInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasState {
  return resultKeypressEvent.hasState;
}
- (KeypressEventState) state {
  return resultKeypressEvent.state;
}
- (KeypressEventBuilder*) setState:(KeypressEventState) value {
  resultKeypressEvent.hasState = YES;
  resultKeypressEvent.state = value;
  return self;
}
- (KeypressEventBuilder*) clearState {
  resultKeypressEvent.hasState = NO;
  resultKeypressEvent.state = KeypressEventStateDown;
  return self;
}
- (BOOL) hasKeycode {
  return resultKeypressEvent.hasKeycode;
}
- (SInt32) keycode {
  return resultKeypressEvent.keycode;
}
- (KeypressEventBuilder*) setKeycode:(SInt32) value {
  resultKeypressEvent.hasKeycode = YES;
  resultKeypressEvent.keycode = value;
  return self;
}
- (KeypressEventBuilder*) clearKeycode {
  resultKeypressEvent.hasKeycode = NO;
  resultKeypressEvent.keycode = 0;
  return self;
}
@end

@interface GestureEvent ()
@property Float32 locationX;
@property Float32 locationY;
@property GestureEventType type;
@property GestureEventState state;
@property SInt32 tapCount;
@property Float32 pinchScale;
@property Float32 pinchVelocity;
@property Float32 panTranslationX;
@property Float32 panTranslationY;
@property Float32 panVelocityX;
@property Float32 panVelocityY;
@property GestureEventSwipeDirection swipeDirection;
@property Float32 rotationAngle;
@property Float32 rotationVelocity;
@property SInt64 pressDuration;
@property GestureEventCircleDirection circleDirection;
@end

@implementation GestureEvent

- (BOOL) hasLocationX {
  return !!hasLocationX_;
}
- (void) setHasLocationX:(BOOL) value_ {
  hasLocationX_ = !!value_;
}
@synthesize locationX;
- (BOOL) hasLocationY {
  return !!hasLocationY_;
}
- (void) setHasLocationY:(BOOL) value_ {
  hasLocationY_ = !!value_;
}
@synthesize locationY;
- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasState {
  return !!hasState_;
}
- (void) setHasState:(BOOL) value_ {
  hasState_ = !!value_;
}
@synthesize state;
- (BOOL) hasTapCount {
  return !!hasTapCount_;
}
- (void) setHasTapCount:(BOOL) value_ {
  hasTapCount_ = !!value_;
}
@synthesize tapCount;
- (BOOL) hasPinchScale {
  return !!hasPinchScale_;
}
- (void) setHasPinchScale:(BOOL) value_ {
  hasPinchScale_ = !!value_;
}
@synthesize pinchScale;
- (BOOL) hasPinchVelocity {
  return !!hasPinchVelocity_;
}
- (void) setHasPinchVelocity:(BOOL) value_ {
  hasPinchVelocity_ = !!value_;
}
@synthesize pinchVelocity;
- (BOOL) hasPanTranslationX {
  return !!hasPanTranslationX_;
}
- (void) setHasPanTranslationX:(BOOL) value_ {
  hasPanTranslationX_ = !!value_;
}
@synthesize panTranslationX;
- (BOOL) hasPanTranslationY {
  return !!hasPanTranslationY_;
}
- (void) setHasPanTranslationY:(BOOL) value_ {
  hasPanTranslationY_ = !!value_;
}
@synthesize panTranslationY;
- (BOOL) hasPanVelocityX {
  return !!hasPanVelocityX_;
}
- (void) setHasPanVelocityX:(BOOL) value_ {
  hasPanVelocityX_ = !!value_;
}
@synthesize panVelocityX;
- (BOOL) hasPanVelocityY {
  return !!hasPanVelocityY_;
}
- (void) setHasPanVelocityY:(BOOL) value_ {
  hasPanVelocityY_ = !!value_;
}
@synthesize panVelocityY;
- (BOOL) hasSwipeDirection {
  return !!hasSwipeDirection_;
}
- (void) setHasSwipeDirection:(BOOL) value_ {
  hasSwipeDirection_ = !!value_;
}
@synthesize swipeDirection;
- (BOOL) hasRotationAngle {
  return !!hasRotationAngle_;
}
- (void) setHasRotationAngle:(BOOL) value_ {
  hasRotationAngle_ = !!value_;
}
@synthesize rotationAngle;
- (BOOL) hasRotationVelocity {
  return !!hasRotationVelocity_;
}
- (void) setHasRotationVelocity:(BOOL) value_ {
  hasRotationVelocity_ = !!value_;
}
@synthesize rotationVelocity;
- (BOOL) hasPressDuration {
  return !!hasPressDuration_;
}
- (void) setHasPressDuration:(BOOL) value_ {
  hasPressDuration_ = !!value_;
}
@synthesize pressDuration;
- (BOOL) hasCircleDirection {
  return !!hasCircleDirection_;
}
- (void) setHasCircleDirection:(BOOL) value_ {
  hasCircleDirection_ = !!value_;
}
@synthesize circleDirection;
- (instancetype) init {
  if ((self = [super init])) {
    self.locationX = 0;
    self.locationY = 0;
    self.type = GestureEventTypeTap;
    self.state = GestureEventStatePossible;
    self.tapCount = 0;
    self.pinchScale = 0;
    self.pinchVelocity = 0;
    self.panTranslationX = 0;
    self.panTranslationY = 0;
    self.panVelocityX = 0;
    self.panVelocityY = 0;
    self.swipeDirection = GestureEventSwipeDirectionRight;
    self.rotationAngle = 0;
    self.rotationVelocity = 0;
    self.pressDuration = 0L;
    self.circleDirection = GestureEventCircleDirectionClockwise;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return GestureEvent_event;
}
static GestureEvent* defaultGestureEventInstance = nil;
+ (void) initialize {
  if (self == [GestureEvent class]) {
    defaultGestureEventInstance = [[GestureEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultGestureEventInstance;
}
- (instancetype) defaultInstance {
  return defaultGestureEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasLocationX) {
    return NO;
  }
  if (!self.hasLocationY) {
    return NO;
  }
  if (!self.hasType) {
    return NO;
  }
  if (!self.hasState) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasLocationX) {
    [output writeFloat:1 value:self.locationX];
  }
  if (self.hasLocationY) {
    [output writeFloat:2 value:self.locationY];
  }
  if (self.hasType) {
    [output writeEnum:3 value:self.type];
  }
  if (self.hasState) {
    [output writeEnum:4 value:self.state];
  }
  if (self.hasTapCount) {
    [output writeInt32:5 value:self.tapCount];
  }
  if (self.hasPinchScale) {
    [output writeFloat:6 value:self.pinchScale];
  }
  if (self.hasPinchVelocity) {
    [output writeFloat:7 value:self.pinchVelocity];
  }
  if (self.hasPanTranslationX) {
    [output writeFloat:8 value:self.panTranslationX];
  }
  if (self.hasPanTranslationY) {
    [output writeFloat:9 value:self.panTranslationY];
  }
  if (self.hasPanVelocityX) {
    [output writeFloat:10 value:self.panVelocityX];
  }
  if (self.hasPanVelocityY) {
    [output writeFloat:11 value:self.panVelocityY];
  }
  if (self.hasSwipeDirection) {
    [output writeEnum:12 value:self.swipeDirection];
  }
  if (self.hasRotationAngle) {
    [output writeFloat:13 value:self.rotationAngle];
  }
  if (self.hasRotationVelocity) {
    [output writeFloat:14 value:self.rotationVelocity];
  }
  if (self.hasPressDuration) {
    [output writeInt64:15 value:self.pressDuration];
  }
  if (self.hasCircleDirection) {
    [output writeEnum:16 value:self.circleDirection];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasLocationX) {
    size_ += computeFloatSize(1, self.locationX);
  }
  if (self.hasLocationY) {
    size_ += computeFloatSize(2, self.locationY);
  }
  if (self.hasType) {
    size_ += computeEnumSize(3, self.type);
  }
  if (self.hasState) {
    size_ += computeEnumSize(4, self.state);
  }
  if (self.hasTapCount) {
    size_ += computeInt32Size(5, self.tapCount);
  }
  if (self.hasPinchScale) {
    size_ += computeFloatSize(6, self.pinchScale);
  }
  if (self.hasPinchVelocity) {
    size_ += computeFloatSize(7, self.pinchVelocity);
  }
  if (self.hasPanTranslationX) {
    size_ += computeFloatSize(8, self.panTranslationX);
  }
  if (self.hasPanTranslationY) {
    size_ += computeFloatSize(9, self.panTranslationY);
  }
  if (self.hasPanVelocityX) {
    size_ += computeFloatSize(10, self.panVelocityX);
  }
  if (self.hasPanVelocityY) {
    size_ += computeFloatSize(11, self.panVelocityY);
  }
  if (self.hasSwipeDirection) {
    size_ += computeEnumSize(12, self.swipeDirection);
  }
  if (self.hasRotationAngle) {
    size_ += computeFloatSize(13, self.rotationAngle);
  }
  if (self.hasRotationVelocity) {
    size_ += computeFloatSize(14, self.rotationVelocity);
  }
  if (self.hasPressDuration) {
    size_ += computeInt64Size(15, self.pressDuration);
  }
  if (self.hasCircleDirection) {
    size_ += computeEnumSize(16, self.circleDirection);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (GestureEvent*) parseFromData:(NSData*) data {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromData:data] build];
}
+ (GestureEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (GestureEvent*) parseFromInputStream:(NSInputStream*) input {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromInputStream:input] build];
}
+ (GestureEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (GestureEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromCodedInputStream:input] build];
}
+ (GestureEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (GestureEvent*)[[[GestureEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (GestureEventBuilder*) builder {
  return [[GestureEventBuilder alloc] init];
}
+ (GestureEventBuilder*) builderWithPrototype:(GestureEvent*) prototype {
  return [[GestureEvent builder] mergeFrom:prototype];
}
- (GestureEventBuilder*) builder {
  return [GestureEvent builder];
}
- (GestureEventBuilder*) toBuilder {
  return [GestureEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasLocationX) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationX", [NSNumber numberWithFloat:self.locationX]];
  }
  if (self.hasLocationY) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationY", [NSNumber numberWithFloat:self.locationY]];
  }
  if (self.hasType) {
    [output appendFormat:@"%@%@: %@\n", indent, @"type", [NSNumber numberWithInteger:self.type]];
  }
  if (self.hasState) {
    [output appendFormat:@"%@%@: %@\n", indent, @"state", [NSNumber numberWithInteger:self.state]];
  }
  if (self.hasTapCount) {
    [output appendFormat:@"%@%@: %@\n", indent, @"tapCount", [NSNumber numberWithInteger:self.tapCount]];
  }
  if (self.hasPinchScale) {
    [output appendFormat:@"%@%@: %@\n", indent, @"pinchScale", [NSNumber numberWithFloat:self.pinchScale]];
  }
  if (self.hasPinchVelocity) {
    [output appendFormat:@"%@%@: %@\n", indent, @"pinchVelocity", [NSNumber numberWithFloat:self.pinchVelocity]];
  }
  if (self.hasPanTranslationX) {
    [output appendFormat:@"%@%@: %@\n", indent, @"panTranslationX", [NSNumber numberWithFloat:self.panTranslationX]];
  }
  if (self.hasPanTranslationY) {
    [output appendFormat:@"%@%@: %@\n", indent, @"panTranslationY", [NSNumber numberWithFloat:self.panTranslationY]];
  }
  if (self.hasPanVelocityX) {
    [output appendFormat:@"%@%@: %@\n", indent, @"panVelocityX", [NSNumber numberWithFloat:self.panVelocityX]];
  }
  if (self.hasPanVelocityY) {
    [output appendFormat:@"%@%@: %@\n", indent, @"panVelocityY", [NSNumber numberWithFloat:self.panVelocityY]];
  }
  if (self.hasSwipeDirection) {
    [output appendFormat:@"%@%@: %@\n", indent, @"swipeDirection", [NSNumber numberWithInteger:self.swipeDirection]];
  }
  if (self.hasRotationAngle) {
    [output appendFormat:@"%@%@: %@\n", indent, @"rotationAngle", [NSNumber numberWithFloat:self.rotationAngle]];
  }
  if (self.hasRotationVelocity) {
    [output appendFormat:@"%@%@: %@\n", indent, @"rotationVelocity", [NSNumber numberWithFloat:self.rotationVelocity]];
  }
  if (self.hasPressDuration) {
    [output appendFormat:@"%@%@: %@\n", indent, @"pressDuration", [NSNumber numberWithLongLong:self.pressDuration]];
  }
  if (self.hasCircleDirection) {
    [output appendFormat:@"%@%@: %@\n", indent, @"circleDirection", [NSNumber numberWithInteger:self.circleDirection]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[GestureEvent class]]) {
    return NO;
  }
  GestureEvent *otherMessage = other;
  return
      self.hasLocationX == otherMessage.hasLocationX &&
      (!self.hasLocationX || self.locationX == otherMessage.locationX) &&
      self.hasLocationY == otherMessage.hasLocationY &&
      (!self.hasLocationY || self.locationY == otherMessage.locationY) &&
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasState == otherMessage.hasState &&
      (!self.hasState || self.state == otherMessage.state) &&
      self.hasTapCount == otherMessage.hasTapCount &&
      (!self.hasTapCount || self.tapCount == otherMessage.tapCount) &&
      self.hasPinchScale == otherMessage.hasPinchScale &&
      (!self.hasPinchScale || self.pinchScale == otherMessage.pinchScale) &&
      self.hasPinchVelocity == otherMessage.hasPinchVelocity &&
      (!self.hasPinchVelocity || self.pinchVelocity == otherMessage.pinchVelocity) &&
      self.hasPanTranslationX == otherMessage.hasPanTranslationX &&
      (!self.hasPanTranslationX || self.panTranslationX == otherMessage.panTranslationX) &&
      self.hasPanTranslationY == otherMessage.hasPanTranslationY &&
      (!self.hasPanTranslationY || self.panTranslationY == otherMessage.panTranslationY) &&
      self.hasPanVelocityX == otherMessage.hasPanVelocityX &&
      (!self.hasPanVelocityX || self.panVelocityX == otherMessage.panVelocityX) &&
      self.hasPanVelocityY == otherMessage.hasPanVelocityY &&
      (!self.hasPanVelocityY || self.panVelocityY == otherMessage.panVelocityY) &&
      self.hasSwipeDirection == otherMessage.hasSwipeDirection &&
      (!self.hasSwipeDirection || self.swipeDirection == otherMessage.swipeDirection) &&
      self.hasRotationAngle == otherMessage.hasRotationAngle &&
      (!self.hasRotationAngle || self.rotationAngle == otherMessage.rotationAngle) &&
      self.hasRotationVelocity == otherMessage.hasRotationVelocity &&
      (!self.hasRotationVelocity || self.rotationVelocity == otherMessage.rotationVelocity) &&
      self.hasPressDuration == otherMessage.hasPressDuration &&
      (!self.hasPressDuration || self.pressDuration == otherMessage.pressDuration) &&
      self.hasCircleDirection == otherMessage.hasCircleDirection &&
      (!self.hasCircleDirection || self.circleDirection == otherMessage.circleDirection) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasLocationX) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationX] hash];
  }
  if (self.hasLocationY) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationY] hash];
  }
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasState) {
    hashCode = hashCode * 31 + self.state;
  }
  if (self.hasTapCount) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.tapCount] hash];
  }
  if (self.hasPinchScale) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.pinchScale] hash];
  }
  if (self.hasPinchVelocity) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.pinchVelocity] hash];
  }
  if (self.hasPanTranslationX) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.panTranslationX] hash];
  }
  if (self.hasPanTranslationY) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.panTranslationY] hash];
  }
  if (self.hasPanVelocityX) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.panVelocityX] hash];
  }
  if (self.hasPanVelocityY) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.panVelocityY] hash];
  }
  if (self.hasSwipeDirection) {
    hashCode = hashCode * 31 + self.swipeDirection;
  }
  if (self.hasRotationAngle) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.rotationAngle] hash];
  }
  if (self.hasRotationVelocity) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.rotationVelocity] hash];
  }
  if (self.hasPressDuration) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.pressDuration] hash];
  }
  if (self.hasCircleDirection) {
    hashCode = hashCode * 31 + self.circleDirection;
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL GestureEventTypeIsValidValue(GestureEventType value) {
  switch (value) {
    case GestureEventTypeTap:
    case GestureEventTypePinch:
    case GestureEventTypePan:
    case GestureEventTypeSwipe:
    case GestureEventTypeRotation:
    case GestureEventTypeLongpress:
    case GestureEventTypeCircle:
    case GestureEventTypeWave:
      return YES;
    default:
      return NO;
  }
}
BOOL GestureEventStateIsValidValue(GestureEventState value) {
  switch (value) {
    case GestureEventStatePossible:
    case GestureEventStateBegan:
    case GestureEventStateChanged:
    case GestureEventStateEnded:
    case GestureEventStateCancelled:
    case GestureEventStateFailed:
      return YES;
    default:
      return NO;
  }
}
BOOL GestureEventSwipeDirectionIsValidValue(GestureEventSwipeDirection value) {
  switch (value) {
    case GestureEventSwipeDirectionRight:
    case GestureEventSwipeDirectionLeft:
    case GestureEventSwipeDirectionUp:
    case GestureEventSwipeDirectionDown:
    case GestureEventSwipeDirectionForward:
    case GestureEventSwipeDirectionBackward:
      return YES;
    default:
      return NO;
  }
}
BOOL GestureEventCircleDirectionIsValidValue(GestureEventCircleDirection value) {
  switch (value) {
    case GestureEventCircleDirectionClockwise:
    case GestureEventCircleDirectionCounterClockwise:
      return YES;
    default:
      return NO;
  }
}
@interface GestureEventBuilder()
@property (strong) GestureEvent* resultGestureEvent;
@end

@implementation GestureEventBuilder
@synthesize resultGestureEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultGestureEvent = [[GestureEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultGestureEvent;
}
- (GestureEventBuilder*) clear {
  self.resultGestureEvent = [[GestureEvent alloc] init];
  return self;
}
- (GestureEventBuilder*) clone {
  return [GestureEvent builderWithPrototype:resultGestureEvent];
}
- (GestureEvent*) defaultInstance {
  return [GestureEvent defaultInstance];
}
- (GestureEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (GestureEvent*) buildPartial {
  GestureEvent* returnMe = resultGestureEvent;
  self.resultGestureEvent = nil;
  return returnMe;
}
- (GestureEventBuilder*) mergeFrom:(GestureEvent*) other {
  if (other == [GestureEvent defaultInstance]) {
    return self;
  }
  if (other.hasLocationX) {
    [self setLocationX:other.locationX];
  }
  if (other.hasLocationY) {
    [self setLocationY:other.locationY];
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasState) {
    [self setState:other.state];
  }
  if (other.hasTapCount) {
    [self setTapCount:other.tapCount];
  }
  if (other.hasPinchScale) {
    [self setPinchScale:other.pinchScale];
  }
  if (other.hasPinchVelocity) {
    [self setPinchVelocity:other.pinchVelocity];
  }
  if (other.hasPanTranslationX) {
    [self setPanTranslationX:other.panTranslationX];
  }
  if (other.hasPanTranslationY) {
    [self setPanTranslationY:other.panTranslationY];
  }
  if (other.hasPanVelocityX) {
    [self setPanVelocityX:other.panVelocityX];
  }
  if (other.hasPanVelocityY) {
    [self setPanVelocityY:other.panVelocityY];
  }
  if (other.hasSwipeDirection) {
    [self setSwipeDirection:other.swipeDirection];
  }
  if (other.hasRotationAngle) {
    [self setRotationAngle:other.rotationAngle];
  }
  if (other.hasRotationVelocity) {
    [self setRotationVelocity:other.rotationVelocity];
  }
  if (other.hasPressDuration) {
    [self setPressDuration:other.pressDuration];
  }
  if (other.hasCircleDirection) {
    [self setCircleDirection:other.circleDirection];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (GestureEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (GestureEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 13: {
        [self setLocationX:[input readFloat]];
        break;
      }
      case 21: {
        [self setLocationY:[input readFloat]];
        break;
      }
      case 24: {
        GestureEventType value = (GestureEventType)[input readEnum];
        if (GestureEventTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:3 value:value];
        }
        break;
      }
      case 32: {
        GestureEventState value = (GestureEventState)[input readEnum];
        if (GestureEventStateIsValidValue(value)) {
          [self setState:value];
        } else {
          [unknownFields mergeVarintField:4 value:value];
        }
        break;
      }
      case 40: {
        [self setTapCount:[input readInt32]];
        break;
      }
      case 53: {
        [self setPinchScale:[input readFloat]];
        break;
      }
      case 61: {
        [self setPinchVelocity:[input readFloat]];
        break;
      }
      case 69: {
        [self setPanTranslationX:[input readFloat]];
        break;
      }
      case 77: {
        [self setPanTranslationY:[input readFloat]];
        break;
      }
      case 85: {
        [self setPanVelocityX:[input readFloat]];
        break;
      }
      case 93: {
        [self setPanVelocityY:[input readFloat]];
        break;
      }
      case 96: {
        GestureEventSwipeDirection value = (GestureEventSwipeDirection)[input readEnum];
        if (GestureEventSwipeDirectionIsValidValue(value)) {
          [self setSwipeDirection:value];
        } else {
          [unknownFields mergeVarintField:12 value:value];
        }
        break;
      }
      case 109: {
        [self setRotationAngle:[input readFloat]];
        break;
      }
      case 117: {
        [self setRotationVelocity:[input readFloat]];
        break;
      }
      case 120: {
        [self setPressDuration:[input readInt64]];
        break;
      }
      case 128: {
        GestureEventCircleDirection value = (GestureEventCircleDirection)[input readEnum];
        if (GestureEventCircleDirectionIsValidValue(value)) {
          [self setCircleDirection:value];
        } else {
          [unknownFields mergeVarintField:16 value:value];
        }
        break;
      }
    }
  }
}
- (BOOL) hasLocationX {
  return resultGestureEvent.hasLocationX;
}
- (Float32) locationX {
  return resultGestureEvent.locationX;
}
- (GestureEventBuilder*) setLocationX:(Float32) value {
  resultGestureEvent.hasLocationX = YES;
  resultGestureEvent.locationX = value;
  return self;
}
- (GestureEventBuilder*) clearLocationX {
  resultGestureEvent.hasLocationX = NO;
  resultGestureEvent.locationX = 0;
  return self;
}
- (BOOL) hasLocationY {
  return resultGestureEvent.hasLocationY;
}
- (Float32) locationY {
  return resultGestureEvent.locationY;
}
- (GestureEventBuilder*) setLocationY:(Float32) value {
  resultGestureEvent.hasLocationY = YES;
  resultGestureEvent.locationY = value;
  return self;
}
- (GestureEventBuilder*) clearLocationY {
  resultGestureEvent.hasLocationY = NO;
  resultGestureEvent.locationY = 0;
  return self;
}
- (BOOL) hasType {
  return resultGestureEvent.hasType;
}
- (GestureEventType) type {
  return resultGestureEvent.type;
}
- (GestureEventBuilder*) setType:(GestureEventType) value {
  resultGestureEvent.hasType = YES;
  resultGestureEvent.type = value;
  return self;
}
- (GestureEventBuilder*) clearType {
  resultGestureEvent.hasType = NO;
  resultGestureEvent.type = GestureEventTypeTap;
  return self;
}
- (BOOL) hasState {
  return resultGestureEvent.hasState;
}
- (GestureEventState) state {
  return resultGestureEvent.state;
}
- (GestureEventBuilder*) setState:(GestureEventState) value {
  resultGestureEvent.hasState = YES;
  resultGestureEvent.state = value;
  return self;
}
- (GestureEventBuilder*) clearState {
  resultGestureEvent.hasState = NO;
  resultGestureEvent.state = GestureEventStatePossible;
  return self;
}
- (BOOL) hasTapCount {
  return resultGestureEvent.hasTapCount;
}
- (SInt32) tapCount {
  return resultGestureEvent.tapCount;
}
- (GestureEventBuilder*) setTapCount:(SInt32) value {
  resultGestureEvent.hasTapCount = YES;
  resultGestureEvent.tapCount = value;
  return self;
}
- (GestureEventBuilder*) clearTapCount {
  resultGestureEvent.hasTapCount = NO;
  resultGestureEvent.tapCount = 0;
  return self;
}
- (BOOL) hasPinchScale {
  return resultGestureEvent.hasPinchScale;
}
- (Float32) pinchScale {
  return resultGestureEvent.pinchScale;
}
- (GestureEventBuilder*) setPinchScale:(Float32) value {
  resultGestureEvent.hasPinchScale = YES;
  resultGestureEvent.pinchScale = value;
  return self;
}
- (GestureEventBuilder*) clearPinchScale {
  resultGestureEvent.hasPinchScale = NO;
  resultGestureEvent.pinchScale = 0;
  return self;
}
- (BOOL) hasPinchVelocity {
  return resultGestureEvent.hasPinchVelocity;
}
- (Float32) pinchVelocity {
  return resultGestureEvent.pinchVelocity;
}
- (GestureEventBuilder*) setPinchVelocity:(Float32) value {
  resultGestureEvent.hasPinchVelocity = YES;
  resultGestureEvent.pinchVelocity = value;
  return self;
}
- (GestureEventBuilder*) clearPinchVelocity {
  resultGestureEvent.hasPinchVelocity = NO;
  resultGestureEvent.pinchVelocity = 0;
  return self;
}
- (BOOL) hasPanTranslationX {
  return resultGestureEvent.hasPanTranslationX;
}
- (Float32) panTranslationX {
  return resultGestureEvent.panTranslationX;
}
- (GestureEventBuilder*) setPanTranslationX:(Float32) value {
  resultGestureEvent.hasPanTranslationX = YES;
  resultGestureEvent.panTranslationX = value;
  return self;
}
- (GestureEventBuilder*) clearPanTranslationX {
  resultGestureEvent.hasPanTranslationX = NO;
  resultGestureEvent.panTranslationX = 0;
  return self;
}
- (BOOL) hasPanTranslationY {
  return resultGestureEvent.hasPanTranslationY;
}
- (Float32) panTranslationY {
  return resultGestureEvent.panTranslationY;
}
- (GestureEventBuilder*) setPanTranslationY:(Float32) value {
  resultGestureEvent.hasPanTranslationY = YES;
  resultGestureEvent.panTranslationY = value;
  return self;
}
- (GestureEventBuilder*) clearPanTranslationY {
  resultGestureEvent.hasPanTranslationY = NO;
  resultGestureEvent.panTranslationY = 0;
  return self;
}
- (BOOL) hasPanVelocityX {
  return resultGestureEvent.hasPanVelocityX;
}
- (Float32) panVelocityX {
  return resultGestureEvent.panVelocityX;
}
- (GestureEventBuilder*) setPanVelocityX:(Float32) value {
  resultGestureEvent.hasPanVelocityX = YES;
  resultGestureEvent.panVelocityX = value;
  return self;
}
- (GestureEventBuilder*) clearPanVelocityX {
  resultGestureEvent.hasPanVelocityX = NO;
  resultGestureEvent.panVelocityX = 0;
  return self;
}
- (BOOL) hasPanVelocityY {
  return resultGestureEvent.hasPanVelocityY;
}
- (Float32) panVelocityY {
  return resultGestureEvent.panVelocityY;
}
- (GestureEventBuilder*) setPanVelocityY:(Float32) value {
  resultGestureEvent.hasPanVelocityY = YES;
  resultGestureEvent.panVelocityY = value;
  return self;
}
- (GestureEventBuilder*) clearPanVelocityY {
  resultGestureEvent.hasPanVelocityY = NO;
  resultGestureEvent.panVelocityY = 0;
  return self;
}
- (BOOL) hasSwipeDirection {
  return resultGestureEvent.hasSwipeDirection;
}
- (GestureEventSwipeDirection) swipeDirection {
  return resultGestureEvent.swipeDirection;
}
- (GestureEventBuilder*) setSwipeDirection:(GestureEventSwipeDirection) value {
  resultGestureEvent.hasSwipeDirection = YES;
  resultGestureEvent.swipeDirection = value;
  return self;
}
- (GestureEventBuilder*) clearSwipeDirection {
  resultGestureEvent.hasSwipeDirection = NO;
  resultGestureEvent.swipeDirection = GestureEventSwipeDirectionRight;
  return self;
}
- (BOOL) hasRotationAngle {
  return resultGestureEvent.hasRotationAngle;
}
- (Float32) rotationAngle {
  return resultGestureEvent.rotationAngle;
}
- (GestureEventBuilder*) setRotationAngle:(Float32) value {
  resultGestureEvent.hasRotationAngle = YES;
  resultGestureEvent.rotationAngle = value;
  return self;
}
- (GestureEventBuilder*) clearRotationAngle {
  resultGestureEvent.hasRotationAngle = NO;
  resultGestureEvent.rotationAngle = 0;
  return self;
}
- (BOOL) hasRotationVelocity {
  return resultGestureEvent.hasRotationVelocity;
}
- (Float32) rotationVelocity {
  return resultGestureEvent.rotationVelocity;
}
- (GestureEventBuilder*) setRotationVelocity:(Float32) value {
  resultGestureEvent.hasRotationVelocity = YES;
  resultGestureEvent.rotationVelocity = value;
  return self;
}
- (GestureEventBuilder*) clearRotationVelocity {
  resultGestureEvent.hasRotationVelocity = NO;
  resultGestureEvent.rotationVelocity = 0;
  return self;
}
- (BOOL) hasPressDuration {
  return resultGestureEvent.hasPressDuration;
}
- (SInt64) pressDuration {
  return resultGestureEvent.pressDuration;
}
- (GestureEventBuilder*) setPressDuration:(SInt64) value {
  resultGestureEvent.hasPressDuration = YES;
  resultGestureEvent.pressDuration = value;
  return self;
}
- (GestureEventBuilder*) clearPressDuration {
  resultGestureEvent.hasPressDuration = NO;
  resultGestureEvent.pressDuration = 0L;
  return self;
}
- (BOOL) hasCircleDirection {
  return resultGestureEvent.hasCircleDirection;
}
- (GestureEventCircleDirection) circleDirection {
  return resultGestureEvent.circleDirection;
}
- (GestureEventBuilder*) setCircleDirection:(GestureEventCircleDirection) value {
  resultGestureEvent.hasCircleDirection = YES;
  resultGestureEvent.circleDirection = value;
  return self;
}
- (GestureEventBuilder*) clearCircleDirection {
  resultGestureEvent.hasCircleDirection = NO;
  resultGestureEvent.circleDirection = GestureEventCircleDirectionClockwise;
  return self;
}
@end

@interface HandMotionEvent ()
@property Float32 locationX;
@property Float32 locationY;
@property HandMotionEventState state;
@property Phase phase;
@property Float32 pitch;
@property Float32 yaw;
@property Float32 roll;
@end

@implementation HandMotionEvent

- (BOOL) hasLocationX {
  return !!hasLocationX_;
}
- (void) setHasLocationX:(BOOL) value_ {
  hasLocationX_ = !!value_;
}
@synthesize locationX;
- (BOOL) hasLocationY {
  return !!hasLocationY_;
}
- (void) setHasLocationY:(BOOL) value_ {
  hasLocationY_ = !!value_;
}
@synthesize locationY;
- (BOOL) hasState {
  return !!hasState_;
}
- (void) setHasState:(BOOL) value_ {
  hasState_ = !!value_;
}
@synthesize state;
- (BOOL) hasPhase {
  return !!hasPhase_;
}
- (void) setHasPhase:(BOOL) value_ {
  hasPhase_ = !!value_;
}
@synthesize phase;
- (BOOL) hasPitch {
  return !!hasPitch_;
}
- (void) setHasPitch:(BOOL) value_ {
  hasPitch_ = !!value_;
}
@synthesize pitch;
- (BOOL) hasYaw {
  return !!hasYaw_;
}
- (void) setHasYaw:(BOOL) value_ {
  hasYaw_ = !!value_;
}
@synthesize yaw;
- (BOOL) hasRoll {
  return !!hasRoll_;
}
- (void) setHasRoll:(BOOL) value_ {
  hasRoll_ = !!value_;
}
@synthesize roll;
- (instancetype) init {
  if ((self = [super init])) {
    self.locationX = 0;
    self.locationY = 0;
    self.state = HandMotionEventStateOpen;
    self.phase = PhaseBegan;
    self.pitch = 0;
    self.yaw = 0;
    self.roll = 0;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return HandMotionEvent_event;
}
static HandMotionEvent* defaultHandMotionEventInstance = nil;
+ (void) initialize {
  if (self == [HandMotionEvent class]) {
    defaultHandMotionEventInstance = [[HandMotionEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultHandMotionEventInstance;
}
- (instancetype) defaultInstance {
  return defaultHandMotionEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasLocationX) {
    return NO;
  }
  if (!self.hasLocationY) {
    return NO;
  }
  if (!self.hasState) {
    return NO;
  }
  if (!self.hasPhase) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasLocationX) {
    [output writeFloat:1 value:self.locationX];
  }
  if (self.hasLocationY) {
    [output writeFloat:2 value:self.locationY];
  }
  if (self.hasState) {
    [output writeEnum:3 value:self.state];
  }
  if (self.hasPhase) {
    [output writeEnum:4 value:self.phase];
  }
  if (self.hasPitch) {
    [output writeFloat:5 value:self.pitch];
  }
  if (self.hasYaw) {
    [output writeFloat:6 value:self.yaw];
  }
  if (self.hasRoll) {
    [output writeFloat:7 value:self.roll];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasLocationX) {
    size_ += computeFloatSize(1, self.locationX);
  }
  if (self.hasLocationY) {
    size_ += computeFloatSize(2, self.locationY);
  }
  if (self.hasState) {
    size_ += computeEnumSize(3, self.state);
  }
  if (self.hasPhase) {
    size_ += computeEnumSize(4, self.phase);
  }
  if (self.hasPitch) {
    size_ += computeFloatSize(5, self.pitch);
  }
  if (self.hasYaw) {
    size_ += computeFloatSize(6, self.yaw);
  }
  if (self.hasRoll) {
    size_ += computeFloatSize(7, self.roll);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (HandMotionEvent*) parseFromData:(NSData*) data {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromData:data] build];
}
+ (HandMotionEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (HandMotionEvent*) parseFromInputStream:(NSInputStream*) input {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromInputStream:input] build];
}
+ (HandMotionEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (HandMotionEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromCodedInputStream:input] build];
}
+ (HandMotionEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HandMotionEvent*)[[[HandMotionEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (HandMotionEventBuilder*) builder {
  return [[HandMotionEventBuilder alloc] init];
}
+ (HandMotionEventBuilder*) builderWithPrototype:(HandMotionEvent*) prototype {
  return [[HandMotionEvent builder] mergeFrom:prototype];
}
- (HandMotionEventBuilder*) builder {
  return [HandMotionEvent builder];
}
- (HandMotionEventBuilder*) toBuilder {
  return [HandMotionEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasLocationX) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationX", [NSNumber numberWithFloat:self.locationX]];
  }
  if (self.hasLocationY) {
    [output appendFormat:@"%@%@: %@\n", indent, @"locationY", [NSNumber numberWithFloat:self.locationY]];
  }
  if (self.hasState) {
    [output appendFormat:@"%@%@: %@\n", indent, @"state", [NSNumber numberWithInteger:self.state]];
  }
  if (self.hasPhase) {
    [output appendFormat:@"%@%@: %@\n", indent, @"phase", [NSNumber numberWithInteger:self.phase]];
  }
  if (self.hasPitch) {
    [output appendFormat:@"%@%@: %@\n", indent, @"pitch", [NSNumber numberWithFloat:self.pitch]];
  }
  if (self.hasYaw) {
    [output appendFormat:@"%@%@: %@\n", indent, @"yaw", [NSNumber numberWithFloat:self.yaw]];
  }
  if (self.hasRoll) {
    [output appendFormat:@"%@%@: %@\n", indent, @"roll", [NSNumber numberWithFloat:self.roll]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[HandMotionEvent class]]) {
    return NO;
  }
  HandMotionEvent *otherMessage = other;
  return
      self.hasLocationX == otherMessage.hasLocationX &&
      (!self.hasLocationX || self.locationX == otherMessage.locationX) &&
      self.hasLocationY == otherMessage.hasLocationY &&
      (!self.hasLocationY || self.locationY == otherMessage.locationY) &&
      self.hasState == otherMessage.hasState &&
      (!self.hasState || self.state == otherMessage.state) &&
      self.hasPhase == otherMessage.hasPhase &&
      (!self.hasPhase || self.phase == otherMessage.phase) &&
      self.hasPitch == otherMessage.hasPitch &&
      (!self.hasPitch || self.pitch == otherMessage.pitch) &&
      self.hasYaw == otherMessage.hasYaw &&
      (!self.hasYaw || self.yaw == otherMessage.yaw) &&
      self.hasRoll == otherMessage.hasRoll &&
      (!self.hasRoll || self.roll == otherMessage.roll) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasLocationX) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationX] hash];
  }
  if (self.hasLocationY) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.locationY] hash];
  }
  if (self.hasState) {
    hashCode = hashCode * 31 + self.state;
  }
  if (self.hasPhase) {
    hashCode = hashCode * 31 + self.phase;
  }
  if (self.hasPitch) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.pitch] hash];
  }
  if (self.hasYaw) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.yaw] hash];
  }
  if (self.hasRoll) {
    hashCode = hashCode * 31 + [[NSNumber numberWithFloat:self.roll] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL HandMotionEventStateIsValidValue(HandMotionEventState value) {
  switch (value) {
    case HandMotionEventStateOpen:
    case HandMotionEventStateGrab:
    case HandMotionEventStatePinch:
      return YES;
    default:
      return NO;
  }
}
@interface HandMotionEventBuilder()
@property (strong) HandMotionEvent* resultHandMotionEvent;
@end

@implementation HandMotionEventBuilder
@synthesize resultHandMotionEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultHandMotionEvent = [[HandMotionEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultHandMotionEvent;
}
- (HandMotionEventBuilder*) clear {
  self.resultHandMotionEvent = [[HandMotionEvent alloc] init];
  return self;
}
- (HandMotionEventBuilder*) clone {
  return [HandMotionEvent builderWithPrototype:resultHandMotionEvent];
}
- (HandMotionEvent*) defaultInstance {
  return [HandMotionEvent defaultInstance];
}
- (HandMotionEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (HandMotionEvent*) buildPartial {
  HandMotionEvent* returnMe = resultHandMotionEvent;
  self.resultHandMotionEvent = nil;
  return returnMe;
}
- (HandMotionEventBuilder*) mergeFrom:(HandMotionEvent*) other {
  if (other == [HandMotionEvent defaultInstance]) {
    return self;
  }
  if (other.hasLocationX) {
    [self setLocationX:other.locationX];
  }
  if (other.hasLocationY) {
    [self setLocationY:other.locationY];
  }
  if (other.hasState) {
    [self setState:other.state];
  }
  if (other.hasPhase) {
    [self setPhase:other.phase];
  }
  if (other.hasPitch) {
    [self setPitch:other.pitch];
  }
  if (other.hasYaw) {
    [self setYaw:other.yaw];
  }
  if (other.hasRoll) {
    [self setRoll:other.roll];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (HandMotionEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (HandMotionEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 13: {
        [self setLocationX:[input readFloat]];
        break;
      }
      case 21: {
        [self setLocationY:[input readFloat]];
        break;
      }
      case 24: {
        HandMotionEventState value = (HandMotionEventState)[input readEnum];
        if (HandMotionEventStateIsValidValue(value)) {
          [self setState:value];
        } else {
          [unknownFields mergeVarintField:3 value:value];
        }
        break;
      }
      case 32: {
        Phase value = (Phase)[input readEnum];
        if (PhaseIsValidValue(value)) {
          [self setPhase:value];
        } else {
          [unknownFields mergeVarintField:4 value:value];
        }
        break;
      }
      case 45: {
        [self setPitch:[input readFloat]];
        break;
      }
      case 53: {
        [self setYaw:[input readFloat]];
        break;
      }
      case 61: {
        [self setRoll:[input readFloat]];
        break;
      }
    }
  }
}
- (BOOL) hasLocationX {
  return resultHandMotionEvent.hasLocationX;
}
- (Float32) locationX {
  return resultHandMotionEvent.locationX;
}
- (HandMotionEventBuilder*) setLocationX:(Float32) value {
  resultHandMotionEvent.hasLocationX = YES;
  resultHandMotionEvent.locationX = value;
  return self;
}
- (HandMotionEventBuilder*) clearLocationX {
  resultHandMotionEvent.hasLocationX = NO;
  resultHandMotionEvent.locationX = 0;
  return self;
}
- (BOOL) hasLocationY {
  return resultHandMotionEvent.hasLocationY;
}
- (Float32) locationY {
  return resultHandMotionEvent.locationY;
}
- (HandMotionEventBuilder*) setLocationY:(Float32) value {
  resultHandMotionEvent.hasLocationY = YES;
  resultHandMotionEvent.locationY = value;
  return self;
}
- (HandMotionEventBuilder*) clearLocationY {
  resultHandMotionEvent.hasLocationY = NO;
  resultHandMotionEvent.locationY = 0;
  return self;
}
- (BOOL) hasState {
  return resultHandMotionEvent.hasState;
}
- (HandMotionEventState) state {
  return resultHandMotionEvent.state;
}
- (HandMotionEventBuilder*) setState:(HandMotionEventState) value {
  resultHandMotionEvent.hasState = YES;
  resultHandMotionEvent.state = value;
  return self;
}
- (HandMotionEventBuilder*) clearState {
  resultHandMotionEvent.hasState = NO;
  resultHandMotionEvent.state = HandMotionEventStateOpen;
  return self;
}
- (BOOL) hasPhase {
  return resultHandMotionEvent.hasPhase;
}
- (Phase) phase {
  return resultHandMotionEvent.phase;
}
- (HandMotionEventBuilder*) setPhase:(Phase) value {
  resultHandMotionEvent.hasPhase = YES;
  resultHandMotionEvent.phase = value;
  return self;
}
- (HandMotionEventBuilder*) clearPhase {
  resultHandMotionEvent.hasPhase = NO;
  resultHandMotionEvent.phase = PhaseBegan;
  return self;
}
- (BOOL) hasPitch {
  return resultHandMotionEvent.hasPitch;
}
- (Float32) pitch {
  return resultHandMotionEvent.pitch;
}
- (HandMotionEventBuilder*) setPitch:(Float32) value {
  resultHandMotionEvent.hasPitch = YES;
  resultHandMotionEvent.pitch = value;
  return self;
}
- (HandMotionEventBuilder*) clearPitch {
  resultHandMotionEvent.hasPitch = NO;
  resultHandMotionEvent.pitch = 0;
  return self;
}
- (BOOL) hasYaw {
  return resultHandMotionEvent.hasYaw;
}
- (Float32) yaw {
  return resultHandMotionEvent.yaw;
}
- (HandMotionEventBuilder*) setYaw:(Float32) value {
  resultHandMotionEvent.hasYaw = YES;
  resultHandMotionEvent.yaw = value;
  return self;
}
- (HandMotionEventBuilder*) clearYaw {
  resultHandMotionEvent.hasYaw = NO;
  resultHandMotionEvent.yaw = 0;
  return self;
}
- (BOOL) hasRoll {
  return resultHandMotionEvent.hasRoll;
}
- (Float32) roll {
  return resultHandMotionEvent.roll;
}
- (HandMotionEventBuilder*) setRoll:(Float32) value {
  resultHandMotionEvent.hasRoll = YES;
  resultHandMotionEvent.roll = value;
  return self;
}
- (HandMotionEventBuilder*) clearRoll {
  resultHandMotionEvent.hasRoll = NO;
  resultHandMotionEvent.roll = 0;
  return self;
}
@end

@interface OAuthRequestEvent ()
@property (strong) NSString* authUrl;
@end

@implementation OAuthRequestEvent

- (BOOL) hasAuthUrl {
  return !!hasAuthUrl_;
}
- (void) setHasAuthUrl:(BOOL) value_ {
  hasAuthUrl_ = !!value_;
}
@synthesize authUrl;
- (instancetype) init {
  if ((self = [super init])) {
    self.authUrl = @"";
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return OAuthRequestEvent_event;
}
static OAuthRequestEvent* defaultOAuthRequestEventInstance = nil;
+ (void) initialize {
  if (self == [OAuthRequestEvent class]) {
    defaultOAuthRequestEventInstance = [[OAuthRequestEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultOAuthRequestEventInstance;
}
- (instancetype) defaultInstance {
  return defaultOAuthRequestEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasAuthUrl) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasAuthUrl) {
    [output writeString:1 value:self.authUrl];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasAuthUrl) {
    size_ += computeStringSize(1, self.authUrl);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (OAuthRequestEvent*) parseFromData:(NSData*) data {
  return (OAuthRequestEvent*)[[[OAuthRequestEvent builder] mergeFromData:data] build];
}
+ (OAuthRequestEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (OAuthRequestEvent*)[[[OAuthRequestEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (OAuthRequestEvent*) parseFromInputStream:(NSInputStream*) input {
  return (OAuthRequestEvent*)[[[OAuthRequestEvent builder] mergeFromInputStream:input] build];
}
+ (OAuthRequestEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (OAuthRequestEvent*)[[[OAuthRequestEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (OAuthRequestEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (OAuthRequestEvent*)[[[OAuthRequestEvent builder] mergeFromCodedInputStream:input] build];
}
+ (OAuthRequestEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (OAuthRequestEvent*)[[[OAuthRequestEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (OAuthRequestEventBuilder*) builder {
  return [[OAuthRequestEventBuilder alloc] init];
}
+ (OAuthRequestEventBuilder*) builderWithPrototype:(OAuthRequestEvent*) prototype {
  return [[OAuthRequestEvent builder] mergeFrom:prototype];
}
- (OAuthRequestEventBuilder*) builder {
  return [OAuthRequestEvent builder];
}
- (OAuthRequestEventBuilder*) toBuilder {
  return [OAuthRequestEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasAuthUrl) {
    [output appendFormat:@"%@%@: %@\n", indent, @"authUrl", self.authUrl];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[OAuthRequestEvent class]]) {
    return NO;
  }
  OAuthRequestEvent *otherMessage = other;
  return
      self.hasAuthUrl == otherMessage.hasAuthUrl &&
      (!self.hasAuthUrl || [self.authUrl isEqual:otherMessage.authUrl]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasAuthUrl) {
    hashCode = hashCode * 31 + [self.authUrl hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface OAuthRequestEventBuilder()
@property (strong) OAuthRequestEvent* resultOauthRequestEvent;
@end

@implementation OAuthRequestEventBuilder
@synthesize resultOauthRequestEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultOauthRequestEvent = [[OAuthRequestEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultOauthRequestEvent;
}
- (OAuthRequestEventBuilder*) clear {
  self.resultOauthRequestEvent = [[OAuthRequestEvent alloc] init];
  return self;
}
- (OAuthRequestEventBuilder*) clone {
  return [OAuthRequestEvent builderWithPrototype:resultOauthRequestEvent];
}
- (OAuthRequestEvent*) defaultInstance {
  return [OAuthRequestEvent defaultInstance];
}
- (OAuthRequestEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (OAuthRequestEvent*) buildPartial {
  OAuthRequestEvent* returnMe = resultOauthRequestEvent;
  self.resultOauthRequestEvent = nil;
  return returnMe;
}
- (OAuthRequestEventBuilder*) mergeFrom:(OAuthRequestEvent*) other {
  if (other == [OAuthRequestEvent defaultInstance]) {
    return self;
  }
  if (other.hasAuthUrl) {
    [self setAuthUrl:other.authUrl];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (OAuthRequestEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (OAuthRequestEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setAuthUrl:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasAuthUrl {
  return resultOauthRequestEvent.hasAuthUrl;
}
- (NSString*) authUrl {
  return resultOauthRequestEvent.authUrl;
}
- (OAuthRequestEventBuilder*) setAuthUrl:(NSString*) value {
  resultOauthRequestEvent.hasAuthUrl = YES;
  resultOauthRequestEvent.authUrl = value;
  return self;
}
- (OAuthRequestEventBuilder*) clearAuthUrl {
  resultOauthRequestEvent.hasAuthUrl = NO;
  resultOauthRequestEvent.authUrl = @"";
  return self;
}
@end

@interface OAuthResponseEvent ()
@property (strong) NSString* authCode;
@end

@implementation OAuthResponseEvent

- (BOOL) hasAuthCode {
  return !!hasAuthCode_;
}
- (void) setHasAuthCode:(BOOL) value_ {
  hasAuthCode_ = !!value_;
}
@synthesize authCode;
- (instancetype) init {
  if ((self = [super init])) {
    self.authCode = @"";
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return OAuthResponseEvent_event;
}
static OAuthResponseEvent* defaultOAuthResponseEventInstance = nil;
+ (void) initialize {
  if (self == [OAuthResponseEvent class]) {
    defaultOAuthResponseEventInstance = [[OAuthResponseEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultOAuthResponseEventInstance;
}
- (instancetype) defaultInstance {
  return defaultOAuthResponseEventInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasAuthCode) {
    [output writeString:1 value:self.authCode];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasAuthCode) {
    size_ += computeStringSize(1, self.authCode);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (OAuthResponseEvent*) parseFromData:(NSData*) data {
  return (OAuthResponseEvent*)[[[OAuthResponseEvent builder] mergeFromData:data] build];
}
+ (OAuthResponseEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (OAuthResponseEvent*)[[[OAuthResponseEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (OAuthResponseEvent*) parseFromInputStream:(NSInputStream*) input {
  return (OAuthResponseEvent*)[[[OAuthResponseEvent builder] mergeFromInputStream:input] build];
}
+ (OAuthResponseEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (OAuthResponseEvent*)[[[OAuthResponseEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (OAuthResponseEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (OAuthResponseEvent*)[[[OAuthResponseEvent builder] mergeFromCodedInputStream:input] build];
}
+ (OAuthResponseEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (OAuthResponseEvent*)[[[OAuthResponseEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (OAuthResponseEventBuilder*) builder {
  return [[OAuthResponseEventBuilder alloc] init];
}
+ (OAuthResponseEventBuilder*) builderWithPrototype:(OAuthResponseEvent*) prototype {
  return [[OAuthResponseEvent builder] mergeFrom:prototype];
}
- (OAuthResponseEventBuilder*) builder {
  return [OAuthResponseEvent builder];
}
- (OAuthResponseEventBuilder*) toBuilder {
  return [OAuthResponseEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasAuthCode) {
    [output appendFormat:@"%@%@: %@\n", indent, @"authCode", self.authCode];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[OAuthResponseEvent class]]) {
    return NO;
  }
  OAuthResponseEvent *otherMessage = other;
  return
      self.hasAuthCode == otherMessage.hasAuthCode &&
      (!self.hasAuthCode || [self.authCode isEqual:otherMessage.authCode]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasAuthCode) {
    hashCode = hashCode * 31 + [self.authCode hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface OAuthResponseEventBuilder()
@property (strong) OAuthResponseEvent* resultOauthResponseEvent;
@end

@implementation OAuthResponseEventBuilder
@synthesize resultOauthResponseEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultOauthResponseEvent = [[OAuthResponseEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultOauthResponseEvent;
}
- (OAuthResponseEventBuilder*) clear {
  self.resultOauthResponseEvent = [[OAuthResponseEvent alloc] init];
  return self;
}
- (OAuthResponseEventBuilder*) clone {
  return [OAuthResponseEvent builderWithPrototype:resultOauthResponseEvent];
}
- (OAuthResponseEvent*) defaultInstance {
  return [OAuthResponseEvent defaultInstance];
}
- (OAuthResponseEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (OAuthResponseEvent*) buildPartial {
  OAuthResponseEvent* returnMe = resultOauthResponseEvent;
  self.resultOauthResponseEvent = nil;
  return returnMe;
}
- (OAuthResponseEventBuilder*) mergeFrom:(OAuthResponseEvent*) other {
  if (other == [OAuthResponseEvent defaultInstance]) {
    return self;
  }
  if (other.hasAuthCode) {
    [self setAuthCode:other.authCode];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (OAuthResponseEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (OAuthResponseEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setAuthCode:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasAuthCode {
  return resultOauthResponseEvent.hasAuthCode;
}
- (NSString*) authCode {
  return resultOauthResponseEvent.authCode;
}
- (OAuthResponseEventBuilder*) setAuthCode:(NSString*) value {
  resultOauthResponseEvent.hasAuthCode = YES;
  resultOauthResponseEvent.authCode = value;
  return self;
}
- (OAuthResponseEventBuilder*) clearAuthCode {
  resultOauthResponseEvent.hasAuthCode = NO;
  resultOauthResponseEvent.authCode = @"";
  return self;
}
@end

@interface WifiNetwork ()
@property (strong) NSString* ssid;
@property SInt32 strength;
@property (strong) NSString* bssid;
@property (strong) NSString* capabilities;
@end

@implementation WifiNetwork

- (BOOL) hasSsid {
  return !!hasSsid_;
}
- (void) setHasSsid:(BOOL) value_ {
  hasSsid_ = !!value_;
}
@synthesize ssid;
- (BOOL) hasStrength {
  return !!hasStrength_;
}
- (void) setHasStrength:(BOOL) value_ {
  hasStrength_ = !!value_;
}
@synthesize strength;
- (BOOL) hasBssid {
  return !!hasBssid_;
}
- (void) setHasBssid:(BOOL) value_ {
  hasBssid_ = !!value_;
}
@synthesize bssid;
- (BOOL) hasCapabilities {
  return !!hasCapabilities_;
}
- (void) setHasCapabilities:(BOOL) value_ {
  hasCapabilities_ = !!value_;
}
@synthesize capabilities;
- (instancetype) init {
  if ((self = [super init])) {
    self.ssid = @"";
    self.strength = 0;
    self.bssid = @"";
    self.capabilities = @"";
  }
  return self;
}
static WifiNetwork* defaultWifiNetworkInstance = nil;
+ (void) initialize {
  if (self == [WifiNetwork class]) {
    defaultWifiNetworkInstance = [[WifiNetwork alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultWifiNetworkInstance;
}
- (instancetype) defaultInstance {
  return defaultWifiNetworkInstance;
}
- (BOOL) isInitialized {
  if (!self.hasSsid) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasSsid) {
    [output writeString:1 value:self.ssid];
  }
  if (self.hasStrength) {
    [output writeInt32:2 value:self.strength];
  }
  if (self.hasBssid) {
    [output writeString:3 value:self.bssid];
  }
  if (self.hasCapabilities) {
    [output writeString:4 value:self.capabilities];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasSsid) {
    size_ += computeStringSize(1, self.ssid);
  }
  if (self.hasStrength) {
    size_ += computeInt32Size(2, self.strength);
  }
  if (self.hasBssid) {
    size_ += computeStringSize(3, self.bssid);
  }
  if (self.hasCapabilities) {
    size_ += computeStringSize(4, self.capabilities);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (WifiNetwork*) parseFromData:(NSData*) data {
  return (WifiNetwork*)[[[WifiNetwork builder] mergeFromData:data] build];
}
+ (WifiNetwork*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (WifiNetwork*)[[[WifiNetwork builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (WifiNetwork*) parseFromInputStream:(NSInputStream*) input {
  return (WifiNetwork*)[[[WifiNetwork builder] mergeFromInputStream:input] build];
}
+ (WifiNetwork*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (WifiNetwork*)[[[WifiNetwork builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (WifiNetwork*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (WifiNetwork*)[[[WifiNetwork builder] mergeFromCodedInputStream:input] build];
}
+ (WifiNetwork*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (WifiNetwork*)[[[WifiNetwork builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (WifiNetworkBuilder*) builder {
  return [[WifiNetworkBuilder alloc] init];
}
+ (WifiNetworkBuilder*) builderWithPrototype:(WifiNetwork*) prototype {
  return [[WifiNetwork builder] mergeFrom:prototype];
}
- (WifiNetworkBuilder*) builder {
  return [WifiNetwork builder];
}
- (WifiNetworkBuilder*) toBuilder {
  return [WifiNetwork builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasSsid) {
    [output appendFormat:@"%@%@: %@\n", indent, @"ssid", self.ssid];
  }
  if (self.hasStrength) {
    [output appendFormat:@"%@%@: %@\n", indent, @"strength", [NSNumber numberWithInteger:self.strength]];
  }
  if (self.hasBssid) {
    [output appendFormat:@"%@%@: %@\n", indent, @"bssid", self.bssid];
  }
  if (self.hasCapabilities) {
    [output appendFormat:@"%@%@: %@\n", indent, @"capabilities", self.capabilities];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[WifiNetwork class]]) {
    return NO;
  }
  WifiNetwork *otherMessage = other;
  return
      self.hasSsid == otherMessage.hasSsid &&
      (!self.hasSsid || [self.ssid isEqual:otherMessage.ssid]) &&
      self.hasStrength == otherMessage.hasStrength &&
      (!self.hasStrength || self.strength == otherMessage.strength) &&
      self.hasBssid == otherMessage.hasBssid &&
      (!self.hasBssid || [self.bssid isEqual:otherMessage.bssid]) &&
      self.hasCapabilities == otherMessage.hasCapabilities &&
      (!self.hasCapabilities || [self.capabilities isEqual:otherMessage.capabilities]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasSsid) {
    hashCode = hashCode * 31 + [self.ssid hash];
  }
  if (self.hasStrength) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.strength] hash];
  }
  if (self.hasBssid) {
    hashCode = hashCode * 31 + [self.bssid hash];
  }
  if (self.hasCapabilities) {
    hashCode = hashCode * 31 + [self.capabilities hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface WifiNetworkBuilder()
@property (strong) WifiNetwork* resultWifiNetwork;
@end

@implementation WifiNetworkBuilder
@synthesize resultWifiNetwork;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultWifiNetwork = [[WifiNetwork alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultWifiNetwork;
}
- (WifiNetworkBuilder*) clear {
  self.resultWifiNetwork = [[WifiNetwork alloc] init];
  return self;
}
- (WifiNetworkBuilder*) clone {
  return [WifiNetwork builderWithPrototype:resultWifiNetwork];
}
- (WifiNetwork*) defaultInstance {
  return [WifiNetwork defaultInstance];
}
- (WifiNetwork*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (WifiNetwork*) buildPartial {
  WifiNetwork* returnMe = resultWifiNetwork;
  self.resultWifiNetwork = nil;
  return returnMe;
}
- (WifiNetworkBuilder*) mergeFrom:(WifiNetwork*) other {
  if (other == [WifiNetwork defaultInstance]) {
    return self;
  }
  if (other.hasSsid) {
    [self setSsid:other.ssid];
  }
  if (other.hasStrength) {
    [self setStrength:other.strength];
  }
  if (other.hasBssid) {
    [self setBssid:other.bssid];
  }
  if (other.hasCapabilities) {
    [self setCapabilities:other.capabilities];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (WifiNetworkBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (WifiNetworkBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setSsid:[input readString]];
        break;
      }
      case 16: {
        [self setStrength:[input readInt32]];
        break;
      }
      case 26: {
        [self setBssid:[input readString]];
        break;
      }
      case 34: {
        [self setCapabilities:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasSsid {
  return resultWifiNetwork.hasSsid;
}
- (NSString*) ssid {
  return resultWifiNetwork.ssid;
}
- (WifiNetworkBuilder*) setSsid:(NSString*) value {
  resultWifiNetwork.hasSsid = YES;
  resultWifiNetwork.ssid = value;
  return self;
}
- (WifiNetworkBuilder*) clearSsid {
  resultWifiNetwork.hasSsid = NO;
  resultWifiNetwork.ssid = @"";
  return self;
}
- (BOOL) hasStrength {
  return resultWifiNetwork.hasStrength;
}
- (SInt32) strength {
  return resultWifiNetwork.strength;
}
- (WifiNetworkBuilder*) setStrength:(SInt32) value {
  resultWifiNetwork.hasStrength = YES;
  resultWifiNetwork.strength = value;
  return self;
}
- (WifiNetworkBuilder*) clearStrength {
  resultWifiNetwork.hasStrength = NO;
  resultWifiNetwork.strength = 0;
  return self;
}
- (BOOL) hasBssid {
  return resultWifiNetwork.hasBssid;
}
- (NSString*) bssid {
  return resultWifiNetwork.bssid;
}
- (WifiNetworkBuilder*) setBssid:(NSString*) value {
  resultWifiNetwork.hasBssid = YES;
  resultWifiNetwork.bssid = value;
  return self;
}
- (WifiNetworkBuilder*) clearBssid {
  resultWifiNetwork.hasBssid = NO;
  resultWifiNetwork.bssid = @"";
  return self;
}
- (BOOL) hasCapabilities {
  return resultWifiNetwork.hasCapabilities;
}
- (NSString*) capabilities {
  return resultWifiNetwork.capabilities;
}
- (WifiNetworkBuilder*) setCapabilities:(NSString*) value {
  resultWifiNetwork.hasCapabilities = YES;
  resultWifiNetwork.capabilities = value;
  return self;
}
- (WifiNetworkBuilder*) clearCapabilities {
  resultWifiNetwork.hasCapabilities = NO;
  resultWifiNetwork.capabilities = @"";
  return self;
}
@end

@interface SetupRequestEvent ()
@property SetupPhase phase;
@property (strong) NSString* name;
@property (strong) NSString* ssid;
@property (strong) NSString* password;
@property BOOL back;
@end

@implementation SetupRequestEvent

- (BOOL) hasPhase {
  return !!hasPhase_;
}
- (void) setHasPhase:(BOOL) value_ {
  hasPhase_ = !!value_;
}
@synthesize phase;
- (BOOL) hasName {
  return !!hasName_;
}
- (void) setHasName:(BOOL) value_ {
  hasName_ = !!value_;
}
@synthesize name;
- (BOOL) hasSsid {
  return !!hasSsid_;
}
- (void) setHasSsid:(BOOL) value_ {
  hasSsid_ = !!value_;
}
@synthesize ssid;
- (BOOL) hasPassword {
  return !!hasPassword_;
}
- (void) setHasPassword:(BOOL) value_ {
  hasPassword_ = !!value_;
}
@synthesize password;
- (BOOL) hasBack {
  return !!hasBack_;
}
- (void) setHasBack:(BOOL) value_ {
  hasBack_ = !!value_;
}
- (BOOL) back {
  return !!back_;
}
- (void) setBack:(BOOL) value_ {
  back_ = !!value_;
}
- (instancetype) init {
  if ((self = [super init])) {
    self.phase = SetupPhaseRequestCode;
    self.name = @"";
    self.ssid = @"";
    self.password = @"";
    self.back = NO;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return SetupRequestEvent_event;
}
static SetupRequestEvent* defaultSetupRequestEventInstance = nil;
+ (void) initialize {
  if (self == [SetupRequestEvent class]) {
    defaultSetupRequestEventInstance = [[SetupRequestEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultSetupRequestEventInstance;
}
- (instancetype) defaultInstance {
  return defaultSetupRequestEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasPhase) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasPhase) {
    [output writeEnum:1 value:self.phase];
  }
  if (self.hasName) {
    [output writeString:2 value:self.name];
  }
  if (self.hasSsid) {
    [output writeString:3 value:self.ssid];
  }
  if (self.hasPassword) {
    [output writeString:4 value:self.password];
  }
  if (self.hasBack) {
    [output writeBool:5 value:self.back];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasPhase) {
    size_ += computeEnumSize(1, self.phase);
  }
  if (self.hasName) {
    size_ += computeStringSize(2, self.name);
  }
  if (self.hasSsid) {
    size_ += computeStringSize(3, self.ssid);
  }
  if (self.hasPassword) {
    size_ += computeStringSize(4, self.password);
  }
  if (self.hasBack) {
    size_ += computeBoolSize(5, self.back);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (SetupRequestEvent*) parseFromData:(NSData*) data {
  return (SetupRequestEvent*)[[[SetupRequestEvent builder] mergeFromData:data] build];
}
+ (SetupRequestEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (SetupRequestEvent*)[[[SetupRequestEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (SetupRequestEvent*) parseFromInputStream:(NSInputStream*) input {
  return (SetupRequestEvent*)[[[SetupRequestEvent builder] mergeFromInputStream:input] build];
}
+ (SetupRequestEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (SetupRequestEvent*)[[[SetupRequestEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (SetupRequestEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (SetupRequestEvent*)[[[SetupRequestEvent builder] mergeFromCodedInputStream:input] build];
}
+ (SetupRequestEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (SetupRequestEvent*)[[[SetupRequestEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (SetupRequestEventBuilder*) builder {
  return [[SetupRequestEventBuilder alloc] init];
}
+ (SetupRequestEventBuilder*) builderWithPrototype:(SetupRequestEvent*) prototype {
  return [[SetupRequestEvent builder] mergeFrom:prototype];
}
- (SetupRequestEventBuilder*) builder {
  return [SetupRequestEvent builder];
}
- (SetupRequestEventBuilder*) toBuilder {
  return [SetupRequestEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasPhase) {
    [output appendFormat:@"%@%@: %@\n", indent, @"phase", [NSNumber numberWithInteger:self.phase]];
  }
  if (self.hasName) {
    [output appendFormat:@"%@%@: %@\n", indent, @"name", self.name];
  }
  if (self.hasSsid) {
    [output appendFormat:@"%@%@: %@\n", indent, @"ssid", self.ssid];
  }
  if (self.hasPassword) {
    [output appendFormat:@"%@%@: %@\n", indent, @"password", self.password];
  }
  if (self.hasBack) {
    [output appendFormat:@"%@%@: %@\n", indent, @"back", [NSNumber numberWithBool:self.back]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[SetupRequestEvent class]]) {
    return NO;
  }
  SetupRequestEvent *otherMessage = other;
  return
      self.hasPhase == otherMessage.hasPhase &&
      (!self.hasPhase || self.phase == otherMessage.phase) &&
      self.hasName == otherMessage.hasName &&
      (!self.hasName || [self.name isEqual:otherMessage.name]) &&
      self.hasSsid == otherMessage.hasSsid &&
      (!self.hasSsid || [self.ssid isEqual:otherMessage.ssid]) &&
      self.hasPassword == otherMessage.hasPassword &&
      (!self.hasPassword || [self.password isEqual:otherMessage.password]) &&
      self.hasBack == otherMessage.hasBack &&
      (!self.hasBack || self.back == otherMessage.back) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasPhase) {
    hashCode = hashCode * 31 + self.phase;
  }
  if (self.hasName) {
    hashCode = hashCode * 31 + [self.name hash];
  }
  if (self.hasSsid) {
    hashCode = hashCode * 31 + [self.ssid hash];
  }
  if (self.hasPassword) {
    hashCode = hashCode * 31 + [self.password hash];
  }
  if (self.hasBack) {
    hashCode = hashCode * 31 + [[NSNumber numberWithBool:self.back] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface SetupRequestEventBuilder()
@property (strong) SetupRequestEvent* resultSetupRequestEvent;
@end

@implementation SetupRequestEventBuilder
@synthesize resultSetupRequestEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultSetupRequestEvent = [[SetupRequestEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultSetupRequestEvent;
}
- (SetupRequestEventBuilder*) clear {
  self.resultSetupRequestEvent = [[SetupRequestEvent alloc] init];
  return self;
}
- (SetupRequestEventBuilder*) clone {
  return [SetupRequestEvent builderWithPrototype:resultSetupRequestEvent];
}
- (SetupRequestEvent*) defaultInstance {
  return [SetupRequestEvent defaultInstance];
}
- (SetupRequestEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (SetupRequestEvent*) buildPartial {
  SetupRequestEvent* returnMe = resultSetupRequestEvent;
  self.resultSetupRequestEvent = nil;
  return returnMe;
}
- (SetupRequestEventBuilder*) mergeFrom:(SetupRequestEvent*) other {
  if (other == [SetupRequestEvent defaultInstance]) {
    return self;
  }
  if (other.hasPhase) {
    [self setPhase:other.phase];
  }
  if (other.hasName) {
    [self setName:other.name];
  }
  if (other.hasSsid) {
    [self setSsid:other.ssid];
  }
  if (other.hasPassword) {
    [self setPassword:other.password];
  }
  if (other.hasBack) {
    [self setBack:other.back];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (SetupRequestEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (SetupRequestEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        SetupPhase value = (SetupPhase)[input readEnum];
        if (SetupPhaseIsValidValue(value)) {
          [self setPhase:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 18: {
        [self setName:[input readString]];
        break;
      }
      case 26: {
        [self setSsid:[input readString]];
        break;
      }
      case 34: {
        [self setPassword:[input readString]];
        break;
      }
      case 40: {
        [self setBack:[input readBool]];
        break;
      }
    }
  }
}
- (BOOL) hasPhase {
  return resultSetupRequestEvent.hasPhase;
}
- (SetupPhase) phase {
  return resultSetupRequestEvent.phase;
}
- (SetupRequestEventBuilder*) setPhase:(SetupPhase) value {
  resultSetupRequestEvent.hasPhase = YES;
  resultSetupRequestEvent.phase = value;
  return self;
}
- (SetupRequestEventBuilder*) clearPhase {
  resultSetupRequestEvent.hasPhase = NO;
  resultSetupRequestEvent.phase = SetupPhaseRequestCode;
  return self;
}
- (BOOL) hasName {
  return resultSetupRequestEvent.hasName;
}
- (NSString*) name {
  return resultSetupRequestEvent.name;
}
- (SetupRequestEventBuilder*) setName:(NSString*) value {
  resultSetupRequestEvent.hasName = YES;
  resultSetupRequestEvent.name = value;
  return self;
}
- (SetupRequestEventBuilder*) clearName {
  resultSetupRequestEvent.hasName = NO;
  resultSetupRequestEvent.name = @"";
  return self;
}
- (BOOL) hasSsid {
  return resultSetupRequestEvent.hasSsid;
}
- (NSString*) ssid {
  return resultSetupRequestEvent.ssid;
}
- (SetupRequestEventBuilder*) setSsid:(NSString*) value {
  resultSetupRequestEvent.hasSsid = YES;
  resultSetupRequestEvent.ssid = value;
  return self;
}
- (SetupRequestEventBuilder*) clearSsid {
  resultSetupRequestEvent.hasSsid = NO;
  resultSetupRequestEvent.ssid = @"";
  return self;
}
- (BOOL) hasPassword {
  return resultSetupRequestEvent.hasPassword;
}
- (NSString*) password {
  return resultSetupRequestEvent.password;
}
- (SetupRequestEventBuilder*) setPassword:(NSString*) value {
  resultSetupRequestEvent.hasPassword = YES;
  resultSetupRequestEvent.password = value;
  return self;
}
- (SetupRequestEventBuilder*) clearPassword {
  resultSetupRequestEvent.hasPassword = NO;
  resultSetupRequestEvent.password = @"";
  return self;
}
- (BOOL) hasBack {
  return resultSetupRequestEvent.hasBack;
}
- (BOOL) back {
  return resultSetupRequestEvent.back;
}
- (SetupRequestEventBuilder*) setBack:(BOOL) value {
  resultSetupRequestEvent.hasBack = YES;
  resultSetupRequestEvent.back = value;
  return self;
}
- (SetupRequestEventBuilder*) clearBack {
  resultSetupRequestEvent.hasBack = NO;
  resultSetupRequestEvent.back = NO;
  return self;
}
@end

@interface SetupResponseEvent ()
@property SetupPhase phase;
@property BOOL error;
@property (strong) NSString* errorMessage;
@property (strong) NSString* code;
@property (strong) NSMutableArray * wifiNetworksArray;
@end

@implementation SetupResponseEvent

- (BOOL) hasPhase {
  return !!hasPhase_;
}
- (void) setHasPhase:(BOOL) value_ {
  hasPhase_ = !!value_;
}
@synthesize phase;
- (BOOL) hasError {
  return !!hasError_;
}
- (void) setHasError:(BOOL) value_ {
  hasError_ = !!value_;
}
- (BOOL) error {
  return !!error_;
}
- (void) setError:(BOOL) value_ {
  error_ = !!value_;
}
- (BOOL) hasErrorMessage {
  return !!hasErrorMessage_;
}
- (void) setHasErrorMessage:(BOOL) value_ {
  hasErrorMessage_ = !!value_;
}
@synthesize errorMessage;
- (BOOL) hasCode {
  return !!hasCode_;
}
- (void) setHasCode:(BOOL) value_ {
  hasCode_ = !!value_;
}
@synthesize code;
@synthesize wifiNetworksArray;
@dynamic wifiNetworks;
- (instancetype) init {
  if ((self = [super init])) {
    self.phase = SetupPhaseRequestCode;
    self.error = NO;
    self.errorMessage = @"";
    self.code = @"";
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return SetupResponseEvent_event;
}
static SetupResponseEvent* defaultSetupResponseEventInstance = nil;
+ (void) initialize {
  if (self == [SetupResponseEvent class]) {
    defaultSetupResponseEventInstance = [[SetupResponseEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultSetupResponseEventInstance;
}
- (instancetype) defaultInstance {
  return defaultSetupResponseEventInstance;
}
- (NSArray *)wifiNetworks {
  return wifiNetworksArray;
}
- (WifiNetwork*)wifiNetworksAtIndex:(NSUInteger)index {
  return [wifiNetworksArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  if (!self.hasPhase) {
    return NO;
  }
  if (!self.hasError) {
    return NO;
  }
  __block BOOL isInitwifiNetworks = YES;
   [self.wifiNetworks enumerateObjectsUsingBlock:^(WifiNetwork *element, NSUInteger idx, BOOL *stop) {
    if (!element.isInitialized) {
      isInitwifiNetworks = NO;
      *stop = YES;
    }
  }];
  if (!isInitwifiNetworks) return isInitwifiNetworks;
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasPhase) {
    [output writeEnum:1 value:self.phase];
  }
  if (self.hasError) {
    [output writeBool:2 value:self.error];
  }
  if (self.hasErrorMessage) {
    [output writeString:3 value:self.errorMessage];
  }
  if (self.hasCode) {
    [output writeString:4 value:self.code];
  }
  [self.wifiNetworksArray enumerateObjectsUsingBlock:^(WifiNetwork *element, NSUInteger idx, BOOL *stop) {
    [output writeMessage:5 value:element];
  }];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasPhase) {
    size_ += computeEnumSize(1, self.phase);
  }
  if (self.hasError) {
    size_ += computeBoolSize(2, self.error);
  }
  if (self.hasErrorMessage) {
    size_ += computeStringSize(3, self.errorMessage);
  }
  if (self.hasCode) {
    size_ += computeStringSize(4, self.code);
  }
  [self.wifiNetworksArray enumerateObjectsUsingBlock:^(WifiNetwork *element, NSUInteger idx, BOOL *stop) {
    size_ += computeMessageSize(5, element);
  }];
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (SetupResponseEvent*) parseFromData:(NSData*) data {
  return (SetupResponseEvent*)[[[SetupResponseEvent builder] mergeFromData:data] build];
}
+ (SetupResponseEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (SetupResponseEvent*)[[[SetupResponseEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (SetupResponseEvent*) parseFromInputStream:(NSInputStream*) input {
  return (SetupResponseEvent*)[[[SetupResponseEvent builder] mergeFromInputStream:input] build];
}
+ (SetupResponseEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (SetupResponseEvent*)[[[SetupResponseEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (SetupResponseEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (SetupResponseEvent*)[[[SetupResponseEvent builder] mergeFromCodedInputStream:input] build];
}
+ (SetupResponseEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (SetupResponseEvent*)[[[SetupResponseEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (SetupResponseEventBuilder*) builder {
  return [[SetupResponseEventBuilder alloc] init];
}
+ (SetupResponseEventBuilder*) builderWithPrototype:(SetupResponseEvent*) prototype {
  return [[SetupResponseEvent builder] mergeFrom:prototype];
}
- (SetupResponseEventBuilder*) builder {
  return [SetupResponseEvent builder];
}
- (SetupResponseEventBuilder*) toBuilder {
  return [SetupResponseEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasPhase) {
    [output appendFormat:@"%@%@: %@\n", indent, @"phase", [NSNumber numberWithInteger:self.phase]];
  }
  if (self.hasError) {
    [output appendFormat:@"%@%@: %@\n", indent, @"error", [NSNumber numberWithBool:self.error]];
  }
  if (self.hasErrorMessage) {
    [output appendFormat:@"%@%@: %@\n", indent, @"errorMessage", self.errorMessage];
  }
  if (self.hasCode) {
    [output appendFormat:@"%@%@: %@\n", indent, @"code", self.code];
  }
  [self.wifiNetworksArray enumerateObjectsUsingBlock:^(WifiNetwork *element, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@ {\n", indent, @"wifiNetworks"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[SetupResponseEvent class]]) {
    return NO;
  }
  SetupResponseEvent *otherMessage = other;
  return
      self.hasPhase == otherMessage.hasPhase &&
      (!self.hasPhase || self.phase == otherMessage.phase) &&
      self.hasError == otherMessage.hasError &&
      (!self.hasError || self.error == otherMessage.error) &&
      self.hasErrorMessage == otherMessage.hasErrorMessage &&
      (!self.hasErrorMessage || [self.errorMessage isEqual:otherMessage.errorMessage]) &&
      self.hasCode == otherMessage.hasCode &&
      (!self.hasCode || [self.code isEqual:otherMessage.code]) &&
      [self.wifiNetworksArray isEqualToArray:otherMessage.wifiNetworksArray] &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasPhase) {
    hashCode = hashCode * 31 + self.phase;
  }
  if (self.hasError) {
    hashCode = hashCode * 31 + [[NSNumber numberWithBool:self.error] hash];
  }
  if (self.hasErrorMessage) {
    hashCode = hashCode * 31 + [self.errorMessage hash];
  }
  if (self.hasCode) {
    hashCode = hashCode * 31 + [self.code hash];
  }
  [self.wifiNetworksArray enumerateObjectsUsingBlock:^(WifiNetwork *element, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [element hash];
  }];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface SetupResponseEventBuilder()
@property (strong) SetupResponseEvent* resultSetupResponseEvent;
@end

@implementation SetupResponseEventBuilder
@synthesize resultSetupResponseEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultSetupResponseEvent = [[SetupResponseEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultSetupResponseEvent;
}
- (SetupResponseEventBuilder*) clear {
  self.resultSetupResponseEvent = [[SetupResponseEvent alloc] init];
  return self;
}
- (SetupResponseEventBuilder*) clone {
  return [SetupResponseEvent builderWithPrototype:resultSetupResponseEvent];
}
- (SetupResponseEvent*) defaultInstance {
  return [SetupResponseEvent defaultInstance];
}
- (SetupResponseEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (SetupResponseEvent*) buildPartial {
  SetupResponseEvent* returnMe = resultSetupResponseEvent;
  self.resultSetupResponseEvent = nil;
  return returnMe;
}
- (SetupResponseEventBuilder*) mergeFrom:(SetupResponseEvent*) other {
  if (other == [SetupResponseEvent defaultInstance]) {
    return self;
  }
  if (other.hasPhase) {
    [self setPhase:other.phase];
  }
  if (other.hasError) {
    [self setError:other.error];
  }
  if (other.hasErrorMessage) {
    [self setErrorMessage:other.errorMessage];
  }
  if (other.hasCode) {
    [self setCode:other.code];
  }
  if (other.wifiNetworksArray.count > 0) {
    if (resultSetupResponseEvent.wifiNetworksArray == nil) {
      resultSetupResponseEvent.wifiNetworksArray = [[NSMutableArray alloc] initWithArray:other.wifiNetworksArray];
    } else {
      [resultSetupResponseEvent.wifiNetworksArray addObjectsFromArray:other.wifiNetworksArray];
    }
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (SetupResponseEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (SetupResponseEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        SetupPhase value = (SetupPhase)[input readEnum];
        if (SetupPhaseIsValidValue(value)) {
          [self setPhase:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 16: {
        [self setError:[input readBool]];
        break;
      }
      case 26: {
        [self setErrorMessage:[input readString]];
        break;
      }
      case 34: {
        [self setCode:[input readString]];
        break;
      }
      case 42: {
        WifiNetworkBuilder* subBuilder = [WifiNetwork builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addWifiNetworks:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasPhase {
  return resultSetupResponseEvent.hasPhase;
}
- (SetupPhase) phase {
  return resultSetupResponseEvent.phase;
}
- (SetupResponseEventBuilder*) setPhase:(SetupPhase) value {
  resultSetupResponseEvent.hasPhase = YES;
  resultSetupResponseEvent.phase = value;
  return self;
}
- (SetupResponseEventBuilder*) clearPhase {
  resultSetupResponseEvent.hasPhase = NO;
  resultSetupResponseEvent.phase = SetupPhaseRequestCode;
  return self;
}
- (BOOL) hasError {
  return resultSetupResponseEvent.hasError;
}
- (BOOL) error {
  return resultSetupResponseEvent.error;
}
- (SetupResponseEventBuilder*) setError:(BOOL) value {
  resultSetupResponseEvent.hasError = YES;
  resultSetupResponseEvent.error = value;
  return self;
}
- (SetupResponseEventBuilder*) clearError {
  resultSetupResponseEvent.hasError = NO;
  resultSetupResponseEvent.error = NO;
  return self;
}
- (BOOL) hasErrorMessage {
  return resultSetupResponseEvent.hasErrorMessage;
}
- (NSString*) errorMessage {
  return resultSetupResponseEvent.errorMessage;
}
- (SetupResponseEventBuilder*) setErrorMessage:(NSString*) value {
  resultSetupResponseEvent.hasErrorMessage = YES;
  resultSetupResponseEvent.errorMessage = value;
  return self;
}
- (SetupResponseEventBuilder*) clearErrorMessage {
  resultSetupResponseEvent.hasErrorMessage = NO;
  resultSetupResponseEvent.errorMessage = @"";
  return self;
}
- (BOOL) hasCode {
  return resultSetupResponseEvent.hasCode;
}
- (NSString*) code {
  return resultSetupResponseEvent.code;
}
- (SetupResponseEventBuilder*) setCode:(NSString*) value {
  resultSetupResponseEvent.hasCode = YES;
  resultSetupResponseEvent.code = value;
  return self;
}
- (SetupResponseEventBuilder*) clearCode {
  resultSetupResponseEvent.hasCode = NO;
  resultSetupResponseEvent.code = @"";
  return self;
}
- (NSMutableArray *)wifiNetworks {
  return resultSetupResponseEvent.wifiNetworksArray;
}
- (WifiNetwork*)wifiNetworksAtIndex:(NSUInteger)index {
  return [resultSetupResponseEvent wifiNetworksAtIndex:index];
}
- (SetupResponseEventBuilder *)addWifiNetworks:(WifiNetwork*)value {
  if (resultSetupResponseEvent.wifiNetworksArray == nil) {
    resultSetupResponseEvent.wifiNetworksArray = [[NSMutableArray alloc]init];
  }
  [resultSetupResponseEvent.wifiNetworksArray addObject:value];
  return self;
}
- (SetupResponseEventBuilder *)setWifiNetworksArray:(NSArray *)array {
  resultSetupResponseEvent.wifiNetworksArray = [[NSMutableArray alloc]initWithArray:array];
  return self;
}
- (SetupResponseEventBuilder *)clearWifiNetworks {
  resultSetupResponseEvent.wifiNetworksArray = nil;
  return self;
}
@end

@interface TextInputRequestEvent ()
@property TextInputRequestEventType type;
@property SInt32 maxLength;
@end

@implementation TextInputRequestEvent

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasMaxLength {
  return !!hasMaxLength_;
}
- (void) setHasMaxLength:(BOOL) value_ {
  hasMaxLength_ = !!value_;
}
@synthesize maxLength;
- (instancetype) init {
  if ((self = [super init])) {
    self.type = TextInputRequestEventTypeText;
    self.maxLength = 0;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return TextInputRequestEvent_event;
}
static TextInputRequestEvent* defaultTextInputRequestEventInstance = nil;
+ (void) initialize {
  if (self == [TextInputRequestEvent class]) {
    defaultTextInputRequestEventInstance = [[TextInputRequestEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultTextInputRequestEventInstance;
}
- (instancetype) defaultInstance {
  return defaultTextInputRequestEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasType) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  if (self.hasMaxLength) {
    [output writeInt32:2 value:self.maxLength];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  if (self.hasMaxLength) {
    size_ += computeInt32Size(2, self.maxLength);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (TextInputRequestEvent*) parseFromData:(NSData*) data {
  return (TextInputRequestEvent*)[[[TextInputRequestEvent builder] mergeFromData:data] build];
}
+ (TextInputRequestEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TextInputRequestEvent*)[[[TextInputRequestEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TextInputRequestEvent*) parseFromInputStream:(NSInputStream*) input {
  return (TextInputRequestEvent*)[[[TextInputRequestEvent builder] mergeFromInputStream:input] build];
}
+ (TextInputRequestEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TextInputRequestEvent*)[[[TextInputRequestEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TextInputRequestEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TextInputRequestEvent*)[[[TextInputRequestEvent builder] mergeFromCodedInputStream:input] build];
}
+ (TextInputRequestEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TextInputRequestEvent*)[[[TextInputRequestEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TextInputRequestEventBuilder*) builder {
  return [[TextInputRequestEventBuilder alloc] init];
}
+ (TextInputRequestEventBuilder*) builderWithPrototype:(TextInputRequestEvent*) prototype {
  return [[TextInputRequestEvent builder] mergeFrom:prototype];
}
- (TextInputRequestEventBuilder*) builder {
  return [TextInputRequestEvent builder];
}
- (TextInputRequestEventBuilder*) toBuilder {
  return [TextInputRequestEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
    [output appendFormat:@"%@%@: %@\n", indent, @"type", [NSNumber numberWithInteger:self.type]];
  }
  if (self.hasMaxLength) {
    [output appendFormat:@"%@%@: %@\n", indent, @"maxLength", [NSNumber numberWithInteger:self.maxLength]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[TextInputRequestEvent class]]) {
    return NO;
  }
  TextInputRequestEvent *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasMaxLength == otherMessage.hasMaxLength &&
      (!self.hasMaxLength || self.maxLength == otherMessage.maxLength) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasMaxLength) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.maxLength] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL TextInputRequestEventTypeIsValidValue(TextInputRequestEventType value) {
  switch (value) {
    case TextInputRequestEventTypeText:
    case TextInputRequestEventTypePassword:
      return YES;
    default:
      return NO;
  }
}
@interface TextInputRequestEventBuilder()
@property (strong) TextInputRequestEvent* resultTextInputRequestEvent;
@end

@implementation TextInputRequestEventBuilder
@synthesize resultTextInputRequestEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultTextInputRequestEvent = [[TextInputRequestEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultTextInputRequestEvent;
}
- (TextInputRequestEventBuilder*) clear {
  self.resultTextInputRequestEvent = [[TextInputRequestEvent alloc] init];
  return self;
}
- (TextInputRequestEventBuilder*) clone {
  return [TextInputRequestEvent builderWithPrototype:resultTextInputRequestEvent];
}
- (TextInputRequestEvent*) defaultInstance {
  return [TextInputRequestEvent defaultInstance];
}
- (TextInputRequestEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TextInputRequestEvent*) buildPartial {
  TextInputRequestEvent* returnMe = resultTextInputRequestEvent;
  self.resultTextInputRequestEvent = nil;
  return returnMe;
}
- (TextInputRequestEventBuilder*) mergeFrom:(TextInputRequestEvent*) other {
  if (other == [TextInputRequestEvent defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasMaxLength) {
    [self setMaxLength:other.maxLength];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TextInputRequestEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TextInputRequestEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        TextInputRequestEventType value = (TextInputRequestEventType)[input readEnum];
        if (TextInputRequestEventTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 16: {
        [self setMaxLength:[input readInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return resultTextInputRequestEvent.hasType;
}
- (TextInputRequestEventType) type {
  return resultTextInputRequestEvent.type;
}
- (TextInputRequestEventBuilder*) setType:(TextInputRequestEventType) value {
  resultTextInputRequestEvent.hasType = YES;
  resultTextInputRequestEvent.type = value;
  return self;
}
- (TextInputRequestEventBuilder*) clearType {
  resultTextInputRequestEvent.hasType = NO;
  resultTextInputRequestEvent.type = TextInputRequestEventTypeText;
  return self;
}
- (BOOL) hasMaxLength {
  return resultTextInputRequestEvent.hasMaxLength;
}
- (SInt32) maxLength {
  return resultTextInputRequestEvent.maxLength;
}
- (TextInputRequestEventBuilder*) setMaxLength:(SInt32) value {
  resultTextInputRequestEvent.hasMaxLength = YES;
  resultTextInputRequestEvent.maxLength = value;
  return self;
}
- (TextInputRequestEventBuilder*) clearMaxLength {
  resultTextInputRequestEvent.hasMaxLength = NO;
  resultTextInputRequestEvent.maxLength = 0;
  return self;
}
@end

@interface TextInputResponseEvent ()
@property TextInputResponseEventState state;
@property (strong) NSString* text;
@property BOOL encrypted;
@end

@implementation TextInputResponseEvent

- (BOOL) hasState {
  return !!hasState_;
}
- (void) setHasState:(BOOL) value_ {
  hasState_ = !!value_;
}
@synthesize state;
- (BOOL) hasText {
  return !!hasText_;
}
- (void) setHasText:(BOOL) value_ {
  hasText_ = !!value_;
}
@synthesize text;
- (BOOL) hasEncrypted {
  return !!hasEncrypted_;
}
- (void) setHasEncrypted:(BOOL) value_ {
  hasEncrypted_ = !!value_;
}
- (BOOL) encrypted {
  return !!encrypted_;
}
- (void) setEncrypted:(BOOL) value_ {
  encrypted_ = !!value_;
}
- (instancetype) init {
  if ((self = [super init])) {
    self.state = TextInputResponseEventStateBegan;
    self.text = @"";
    self.encrypted = NO;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return TextInputResponseEvent_event;
}
static TextInputResponseEvent* defaultTextInputResponseEventInstance = nil;
+ (void) initialize {
  if (self == [TextInputResponseEvent class]) {
    defaultTextInputResponseEventInstance = [[TextInputResponseEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultTextInputResponseEventInstance;
}
- (instancetype) defaultInstance {
  return defaultTextInputResponseEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasState) {
    return NO;
  }
  if (!self.hasText) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasState) {
    [output writeEnum:1 value:self.state];
  }
  if (self.hasText) {
    [output writeString:2 value:self.text];
  }
  if (self.hasEncrypted) {
    [output writeBool:3 value:self.encrypted];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasState) {
    size_ += computeEnumSize(1, self.state);
  }
  if (self.hasText) {
    size_ += computeStringSize(2, self.text);
  }
  if (self.hasEncrypted) {
    size_ += computeBoolSize(3, self.encrypted);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (TextInputResponseEvent*) parseFromData:(NSData*) data {
  return (TextInputResponseEvent*)[[[TextInputResponseEvent builder] mergeFromData:data] build];
}
+ (TextInputResponseEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TextInputResponseEvent*)[[[TextInputResponseEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TextInputResponseEvent*) parseFromInputStream:(NSInputStream*) input {
  return (TextInputResponseEvent*)[[[TextInputResponseEvent builder] mergeFromInputStream:input] build];
}
+ (TextInputResponseEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TextInputResponseEvent*)[[[TextInputResponseEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TextInputResponseEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TextInputResponseEvent*)[[[TextInputResponseEvent builder] mergeFromCodedInputStream:input] build];
}
+ (TextInputResponseEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TextInputResponseEvent*)[[[TextInputResponseEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TextInputResponseEventBuilder*) builder {
  return [[TextInputResponseEventBuilder alloc] init];
}
+ (TextInputResponseEventBuilder*) builderWithPrototype:(TextInputResponseEvent*) prototype {
  return [[TextInputResponseEvent builder] mergeFrom:prototype];
}
- (TextInputResponseEventBuilder*) builder {
  return [TextInputResponseEvent builder];
}
- (TextInputResponseEventBuilder*) toBuilder {
  return [TextInputResponseEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasState) {
    [output appendFormat:@"%@%@: %@\n", indent, @"state", [NSNumber numberWithInteger:self.state]];
  }
  if (self.hasText) {
    [output appendFormat:@"%@%@: %@\n", indent, @"text", self.text];
  }
  if (self.hasEncrypted) {
    [output appendFormat:@"%@%@: %@\n", indent, @"encrypted", [NSNumber numberWithBool:self.encrypted]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[TextInputResponseEvent class]]) {
    return NO;
  }
  TextInputResponseEvent *otherMessage = other;
  return
      self.hasState == otherMessage.hasState &&
      (!self.hasState || self.state == otherMessage.state) &&
      self.hasText == otherMessage.hasText &&
      (!self.hasText || [self.text isEqual:otherMessage.text]) &&
      self.hasEncrypted == otherMessage.hasEncrypted &&
      (!self.hasEncrypted || self.encrypted == otherMessage.encrypted) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasState) {
    hashCode = hashCode * 31 + self.state;
  }
  if (self.hasText) {
    hashCode = hashCode * 31 + [self.text hash];
  }
  if (self.hasEncrypted) {
    hashCode = hashCode * 31 + [[NSNumber numberWithBool:self.encrypted] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL TextInputResponseEventStateIsValidValue(TextInputResponseEventState value) {
  switch (value) {
    case TextInputResponseEventStateBegan:
    case TextInputResponseEventStateChanged:
    case TextInputResponseEventStateEnded:
    case TextInputResponseEventStateCancelled:
      return YES;
    default:
      return NO;
  }
}
@interface TextInputResponseEventBuilder()
@property (strong) TextInputResponseEvent* resultTextInputResponseEvent;
@end

@implementation TextInputResponseEventBuilder
@synthesize resultTextInputResponseEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultTextInputResponseEvent = [[TextInputResponseEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultTextInputResponseEvent;
}
- (TextInputResponseEventBuilder*) clear {
  self.resultTextInputResponseEvent = [[TextInputResponseEvent alloc] init];
  return self;
}
- (TextInputResponseEventBuilder*) clone {
  return [TextInputResponseEvent builderWithPrototype:resultTextInputResponseEvent];
}
- (TextInputResponseEvent*) defaultInstance {
  return [TextInputResponseEvent defaultInstance];
}
- (TextInputResponseEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TextInputResponseEvent*) buildPartial {
  TextInputResponseEvent* returnMe = resultTextInputResponseEvent;
  self.resultTextInputResponseEvent = nil;
  return returnMe;
}
- (TextInputResponseEventBuilder*) mergeFrom:(TextInputResponseEvent*) other {
  if (other == [TextInputResponseEvent defaultInstance]) {
    return self;
  }
  if (other.hasState) {
    [self setState:other.state];
  }
  if (other.hasText) {
    [self setText:other.text];
  }
  if (other.hasEncrypted) {
    [self setEncrypted:other.encrypted];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TextInputResponseEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TextInputResponseEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        TextInputResponseEventState value = (TextInputResponseEventState)[input readEnum];
        if (TextInputResponseEventStateIsValidValue(value)) {
          [self setState:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 18: {
        [self setText:[input readString]];
        break;
      }
      case 24: {
        [self setEncrypted:[input readBool]];
        break;
      }
    }
  }
}
- (BOOL) hasState {
  return resultTextInputResponseEvent.hasState;
}
- (TextInputResponseEventState) state {
  return resultTextInputResponseEvent.state;
}
- (TextInputResponseEventBuilder*) setState:(TextInputResponseEventState) value {
  resultTextInputResponseEvent.hasState = YES;
  resultTextInputResponseEvent.state = value;
  return self;
}
- (TextInputResponseEventBuilder*) clearState {
  resultTextInputResponseEvent.hasState = NO;
  resultTextInputResponseEvent.state = TextInputResponseEventStateBegan;
  return self;
}
- (BOOL) hasText {
  return resultTextInputResponseEvent.hasText;
}
- (NSString*) text {
  return resultTextInputResponseEvent.text;
}
- (TextInputResponseEventBuilder*) setText:(NSString*) value {
  resultTextInputResponseEvent.hasText = YES;
  resultTextInputResponseEvent.text = value;
  return self;
}
- (TextInputResponseEventBuilder*) clearText {
  resultTextInputResponseEvent.hasText = NO;
  resultTextInputResponseEvent.text = @"";
  return self;
}
- (BOOL) hasEncrypted {
  return resultTextInputResponseEvent.hasEncrypted;
}
- (BOOL) encrypted {
  return resultTextInputResponseEvent.encrypted;
}
- (TextInputResponseEventBuilder*) setEncrypted:(BOOL) value {
  resultTextInputResponseEvent.hasEncrypted = YES;
  resultTextInputResponseEvent.encrypted = value;
  return self;
}
- (TextInputResponseEventBuilder*) clearEncrypted {
  resultTextInputResponseEvent.hasEncrypted = NO;
  resultTextInputResponseEvent.encrypted = NO;
  return self;
}
@end

@interface FunctionEvent ()
@property FunctionEventKey key;
@end

@implementation FunctionEvent

- (BOOL) hasKey {
  return !!hasKey_;
}
- (void) setHasKey:(BOOL) value_ {
  hasKey_ = !!value_;
}
@synthesize key;
- (instancetype) init {
  if ((self = [super init])) {
    self.key = FunctionEventKeyF1;
  }
  return self;
}
+ (id<PBExtensionField>) event {
  return FunctionEvent_event;
}
static FunctionEvent* defaultFunctionEventInstance = nil;
+ (void) initialize {
  if (self == [FunctionEvent class]) {
    defaultFunctionEventInstance = [[FunctionEvent alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultFunctionEventInstance;
}
- (instancetype) defaultInstance {
  return defaultFunctionEventInstance;
}
- (BOOL) isInitialized {
  if (!self.hasKey) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasKey) {
    [output writeEnum:1 value:self.key];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasKey) {
    size_ += computeEnumSize(1, self.key);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (FunctionEvent*) parseFromData:(NSData*) data {
  return (FunctionEvent*)[[[FunctionEvent builder] mergeFromData:data] build];
}
+ (FunctionEvent*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FunctionEvent*)[[[FunctionEvent builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FunctionEvent*) parseFromInputStream:(NSInputStream*) input {
  return (FunctionEvent*)[[[FunctionEvent builder] mergeFromInputStream:input] build];
}
+ (FunctionEvent*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FunctionEvent*)[[[FunctionEvent builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FunctionEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FunctionEvent*)[[[FunctionEvent builder] mergeFromCodedInputStream:input] build];
}
+ (FunctionEvent*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FunctionEvent*)[[[FunctionEvent builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FunctionEventBuilder*) builder {
  return [[FunctionEventBuilder alloc] init];
}
+ (FunctionEventBuilder*) builderWithPrototype:(FunctionEvent*) prototype {
  return [[FunctionEvent builder] mergeFrom:prototype];
}
- (FunctionEventBuilder*) builder {
  return [FunctionEvent builder];
}
- (FunctionEventBuilder*) toBuilder {
  return [FunctionEvent builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasKey) {
    [output appendFormat:@"%@%@: %@\n", indent, @"key", [NSNumber numberWithInteger:self.key]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[FunctionEvent class]]) {
    return NO;
  }
  FunctionEvent *otherMessage = other;
  return
      self.hasKey == otherMessage.hasKey &&
      (!self.hasKey || self.key == otherMessage.key) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasKey) {
    hashCode = hashCode * 31 + self.key;
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL FunctionEventKeyIsValidValue(FunctionEventKey value) {
  switch (value) {
    case FunctionEventKeyF1:
    case FunctionEventKeyF2:
    case FunctionEventKeyF3:
    case FunctionEventKeyF4:
    case FunctionEventKeyMediaPlay:
    case FunctionEventKeyMediaPause:
    case FunctionEventKeyMediaFastForward:
    case FunctionEventKeyMediaRewind:
    case FunctionEventKeyMediaStop:
      return YES;
    default:
      return NO;
  }
}
@interface FunctionEventBuilder()
@property (strong) FunctionEvent* resultFunctionEvent;
@end

@implementation FunctionEventBuilder
@synthesize resultFunctionEvent;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultFunctionEvent = [[FunctionEvent alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultFunctionEvent;
}
- (FunctionEventBuilder*) clear {
  self.resultFunctionEvent = [[FunctionEvent alloc] init];
  return self;
}
- (FunctionEventBuilder*) clone {
  return [FunctionEvent builderWithPrototype:resultFunctionEvent];
}
- (FunctionEvent*) defaultInstance {
  return [FunctionEvent defaultInstance];
}
- (FunctionEvent*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FunctionEvent*) buildPartial {
  FunctionEvent* returnMe = resultFunctionEvent;
  self.resultFunctionEvent = nil;
  return returnMe;
}
- (FunctionEventBuilder*) mergeFrom:(FunctionEvent*) other {
  if (other == [FunctionEvent defaultInstance]) {
    return self;
  }
  if (other.hasKey) {
    [self setKey:other.key];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FunctionEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FunctionEventBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        FunctionEventKey value = (FunctionEventKey)[input readEnum];
        if (FunctionEventKeyIsValidValue(value)) {
          [self setKey:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
    }
  }
}
- (BOOL) hasKey {
  return resultFunctionEvent.hasKey;
}
- (FunctionEventKey) key {
  return resultFunctionEvent.key;
}
- (FunctionEventBuilder*) setKey:(FunctionEventKey) value {
  resultFunctionEvent.hasKey = YES;
  resultFunctionEvent.key = value;
  return self;
}
- (FunctionEventBuilder*) clearKey {
  resultFunctionEvent.hasKey = NO;
  resultFunctionEvent.key = FunctionEventKeyF1;
  return self;
}
@end


// @@protoc_insertion_point(global_scope)
